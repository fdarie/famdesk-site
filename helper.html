<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FamDesk â€” Helper View</title>
  <!-- PWA â€” Phase 86 -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0891b2">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FamDesk Helper">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <!-- FamDesk v2.0.6 | P2P â€” no servers -->
  <script>var FAMDESK_VERSION = '2.0.6'</script>
  <style>
    /* â”€â”€ Design System â€” Glass Premium (Concept C) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    :root {
      /* Base */
      --bg:             #080B12;
      --surface:        rgba(255,255,255,0.05);
      --surface-high:   rgba(255,255,255,0.09);
      --surface-low:    rgba(255,255,255,0.03);
      --border:         rgba(255,255,255,0.08);
      --border-bright:  rgba(255,255,255,0.15);
      --shadow:         0 8px 32px rgba(0,0,0,0.6);
      --shadow-xl:      0 16px 48px rgba(0,0,0,0.8);
      --blur:           blur(20px);

      /* Text */
      --text:           #F0F4FF;
      --text-sec:       rgba(240,244,255,0.60);
      --text-muted:     rgba(240,244,255,0.35);

      /* Accent */
      --accent-grad:    linear-gradient(135deg, #6EE7F7 0%, #818CF8 100%);
      --accent-cyan:    #6EE7F7;
      --accent-indigo:  #818CF8;
      --accent-mid:     #7BC4F0;

      /* States */
      --success:        #6EE7F7;
      --danger:         #F87171;
      --danger-bg:      rgba(248,113,113,0.12);

      /* Layout radii */
      --radius-sm:    8px;
      --radius-md:    12px;
      --radius-lg:    16px;
      --radius:       10px;

      /* â”€â”€ Legacy alias map â†’ Glass Premium (keeps old refs working) â”€â”€ */
      --primary:        var(--accent-mid);
      --primary-dark:   var(--accent-indigo);
      --primary-fg:     #080B12;
      --card:           rgba(255,255,255,0.06);
      --surface-2:      var(--surface-high);
      --on-bg:          var(--text);
      --on-bg-2:        var(--text-sec);
      --on-bg-muted:    var(--text-muted);
      --red:            var(--danger);
      --green:          var(--success);
      --amber:          #FBB924;
      --chat-me-bg:     var(--accent-indigo);
      --chat-me-fg:     #F0F4FF;
      --chat-them-bg:   var(--surface-high);
      --chat-them-fg:   var(--text);
      --shadow-lg:      var(--shadow);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
      background: var(--bg);
      background-image: radial-gradient(ellipse at 20% 0%, rgba(110,231,247,0.06) 0%, transparent 60%),
                        radial-gradient(ellipse at 80% 100%, rgba(129,140,248,0.06) 0%, transparent 60%);
      color: var(--text);
      overflow: hidden;
    }

    /* â”€â”€ Connect UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #connectUI {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: var(--bg);
    }
    .connect-card {
      background: var(--surface);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border-radius: var(--radius-lg);
      padding: 40px;
      max-width: 420px;
      width: 100%;
      box-shadow: var(--shadow-xl);
      border: 1px solid var(--border);
    }
    .connect-card h1 {
      font-size: 28px;
      font-weight: 700;
      margin: 0 0 8px;
      background: var(--accent-grad);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .connect-card .tagline {
      color: var(--text-sec);
      font-size: 14px;
      margin: 0 0 32px;
    }

    #codeRow {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    #codeInput {
      font-size: 20px;
      text-align: center;
      letter-spacing: 0.15em;
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--bg);
      color: var(--on-bg);
      width: 100%;
      height: 56px;
      text-transform: uppercase;
      font-family: 'SF Mono', SFMono-Regular, Menlo, Consolas, monospace;
      outline: none;
      transition: border-color 0.15s;
    }
    #codeInput:focus { border-color: var(--accent-indigo); box-shadow: 0 0 0 3px rgba(129,140,248,0.15); caret-color: var(--accent-cyan); }
    #codeInput::placeholder { color: var(--text-muted); letter-spacing: 0.25em; }
    #connectBtn {
      font-size: 16px;
      font-weight: 600;
      padding: 0 22px;
      height: 48px;
      background: var(--accent-grad);
      color: #080B12;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: box-shadow 0.15s, opacity 0.15s;
      width: 100%;
      box-shadow: 0 0 24px rgba(110,231,247,0.20);
    }
    #connectBtn:hover:not(:disabled) { box-shadow: 0 0 32px rgba(110,231,247,0.35); opacity: 0.92; }
    #connectBtn:disabled { opacity: 0.4; cursor: not-allowed; }

    #scanQrBtn {
      font-size: 17px;
      font-weight: 600;
      padding: 16px 14px;
      background: var(--accent-cyan);
      color: #0a0f1e;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      white-space: nowrap;
      transition: opacity 0.15s, transform 0.1s;
      width: 100%;
      letter-spacing: 0.02em;
    }
    #scanQrBtn:hover { opacity: 0.88; transform: translateY(-1px); }
    #scanQrBtn:active { transform: translateY(0); }

    #howto {
      background: var(--surface-low);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 20px;
      width: 100%;
      margin-top: 16px;
    }
    #howto h2 { font-size: 14px; color: var(--accent-cyan); margin-bottom: 12px; font-weight: 600; }
    #howto ol { padding-left: 20px; line-height: 2; font-size: 13px; color: var(--text-sec); }

    /* â”€â”€ Status (connect phase) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #status {
      display: block;
      color: var(--on-bg-2);
      font-size: 14px;
      min-height: 20px;
      text-align: center;
      margin-bottom: 16px;
    }
    #status.connected { color: var(--accent-cyan); text-shadow: 0 0 12px rgba(110,231,247,0.5); }
    #status.error     { color: var(--danger); }
    #status.waiting   { color: var(--amber); }

    /* â”€â”€ Hidden legacy statusBar (preserved for JS compat) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #statusBar { display: none; }

    /* â”€â”€ Session View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #sessionView {
      display: none;
      flex-direction: column;
      height: 100vh;
    }
    #sessionView.active { display: flex; }

    /* Top bar */
    #topBar {
      height: 56px;
      background: rgba(8,11,18,0.85);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
      flex-shrink: 0;
    }
    #topBar .brand {
      font-weight: 700;
      font-size: 16px;
      white-space: nowrap;
      background: var(--accent-grad);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #topBar .session-info {
      flex: 1;
      text-align: center;
      font-size: 13px;
      color: var(--text-sec);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    #topBar .top-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* Top bar badges */
    #fps {
      display: none;
      background: var(--surface);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      color: var(--text-sec);
      font-size: 11px;
      font-family: 'SF Mono', SFMono-Regular, Menlo, Consolas, monospace;
      padding: 3px 10px;
      border-radius: 8px;
      white-space: nowrap;
    }
    #fps.fps-good    { background: rgba(110,231,247,0.12); color: var(--accent-cyan); border-color: rgba(110,231,247,0.2); }
    #fps.fps-low     { background: rgba(248,113,113,0.12); color: var(--danger); border-color: rgba(248,113,113,0.2); }
    #fps.fps-paused  { background: var(--surface); color: var(--text-muted); }
    /* Phase 53: Stream Health Pill */
    .stream-health-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 8px;
      background: var(--surface);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      min-height: 24px;
      font-family: 'SF Mono', SFMono-Regular, Menlo, Consolas, monospace;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      cursor: default;
      color: var(--text-sec);
    }
    .stream-health-pill .health-sep { opacity: 0.4; }
    #zoomBadge {
      display: none;
      background: rgba(251,185,36,0.12);
      color: var(--amber);
      border: 1px solid rgba(251,185,36,0.3);
      border-radius: 8px;
      padding: 2px 7px;
      font-size: 11px;
      font-weight: 700;
      font-family: monospace;
      line-height: 1.4;
    }
    #latencyBadge {
      display: none;
      font-size: 11px;
      font-family: 'SF Mono', SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--text-sec);
      padding: 3px 8px;
      background: var(--surface);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    #privacyBadge {
      display: none;
      background: rgba(110,231,247,0.08);
      color: var(--accent-cyan);
      border: 1px solid rgba(110,231,247,0.2);
      border-radius: 10px;
      padding: 2px 9px;
      font-size: 11px;
      font-family: monospace;
      white-space: nowrap;
      cursor: default;
    }
    #sessionTimer {
      display: none;
      background: var(--surface);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      color: var(--text-sec);
      font-size: 12px;
      font-family: 'SF Mono', SFMono-Regular, Menlo, Consolas, monospace;
      padding: 3px 10px;
      border-radius: 8px;
      white-space: nowrap;
    }

    /* Top bar buttons */
    .top-btn {
      padding: 6px 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      backdrop-filter: var(--blur);
      color: var(--text-sec);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.15s, border-color 0.15s;
      white-space: nowrap;
    }
    .top-btn:hover { background: var(--surface-high); color: var(--text); border-color: var(--border-bright); }
    .top-btn.active { background: var(--accent-grad); color: #080B12; border-color: transparent; }
    #disconnectBtn {
      display: none;
      padding: 6px 14px;
      background: var(--danger-bg);
      color: var(--danger);
      border: 1px solid rgba(248,113,113,0.25);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: background 0.15s;
      white-space: nowrap;
    }
    #disconnectBtn:hover { background: rgba(248,113,113,0.22); }

    /* Main area */
    #mainArea {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Screen wrap */
    #screenWrap {
      flex: 1;
      position: relative;
      background: #0A0D14;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    #screen {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    #annotationCanvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
    }
    #zoomResetBtn {
      position: absolute;
      top: 8px;
      left: 8px;
      background: var(--surface);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      color: var(--amber);
      border-radius: var(--radius);
      padding: 5px 9px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      display: none;
      z-index: 10;
      line-height: 1;
    }
    #zoomResetBtn:hover { background: var(--surface-high); }
    #privacyNote {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      color: rgba(230,237,243,0.7);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      white-space: nowrap;
      pointer-events: none;
      display: none;
    }
    #streamMode {
      position: absolute;
      bottom: 8px;
      right: 8px;
      background: rgba(0,0,0,0.6);
      color: rgba(230,237,243,0.7);
      padding: 3px 10px;
      border-radius: 10px;
      font-size: 11px;
      display: none;
      pointer-events: none;
    }
    #pointerHint {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      color: rgba(230,237,243,0.6);
      padding: 4px 14px;
      border-radius: 12px;
      font-size: 11px;
      white-space: nowrap;
      pointer-events: none;
      display: none;
    }

    /* â”€â”€ Helper webcam PiP (Phase 33) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #helperCamPip {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 120px;
      height: 90px;
      border-radius: 8px;
      border: 2px solid rgba(110,231,247,0.6);
      object-fit: cover;
      display: none;
      z-index: 20;
      cursor: move;
      transform: scaleX(-1); /* mirror for natural selfie-view */
      background: #000;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    }
    #helperCamPip.pip-active { display: block; }
    @media (max-width: 600px) {
      #helperCamPip { width: 80px; height: 60px; }
    }

    /* â”€â”€ Phase 34: Session summary toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #sessionSummary {
      display: none;
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface, #1e2030);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 14px 24px;
      font-size: 14px;
      color: var(--on-bg, #e2e8f0);
      z-index: 9999;
      box-shadow: 0 8px 32px rgba(0,0,0,.5);
      white-space: nowrap;
      animation: summaryFadeIn .3s ease;
    }
    @keyframes summaryFadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(12px); }
      to   { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* â”€â”€ Phase 74: Post-session how-to note card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .session-note-card {
      position: fixed;
      bottom: 28px;
      left: 50%;
      transform: translateX(-50%);
      width: min(480px, calc(100vw - 32px));
      background: var(--surface, rgba(30,32,48,0.97));
      border: 1px solid var(--border, rgba(255,255,255,0.15));
      border-radius: 14px;
      padding: 16px;
      z-index: 9998;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    .session-note-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      font-weight: 600;
      color: var(--on-bg, #e2e8f0);
      margin-bottom: 10px;
    }
    .session-note-dismiss {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-dim, rgba(255,255,255,0.45));
      font-size: 16px;
      padding: 2px 6px;
      line-height: 1;
      min-height: 32px;
      border-radius: 6px;
      transition: color 0.15s;
    }
    .session-note-dismiss:hover { color: var(--on-bg, #e2e8f0); }
    #sessionNoteText {
      width: 100%;
      box-sizing: border-box;
      resize: vertical;
      min-height: 80px;
      background: var(--surface-raised, rgba(255,255,255,0.06));
      border: 1px solid var(--border, rgba(255,255,255,0.2));
      border-radius: 8px;
      color: var(--on-bg, #e2e8f0);
      font-size: 14px;
      font-family: inherit;
      padding: 8px 10px;
      line-height: 1.5;
      outline: none;
    }
    #sessionNoteText:focus {
      border-color: var(--accent-cyan, #22d3ee);
    }
    .session-note-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
      gap: 8px;
    }
    .session-note-charcount {
      font-size: 11px;
      color: var(--text-dim, rgba(255,255,255,0.45));
      font-variant-numeric: tabular-nums;
    }
    .session-note-send {
      background: var(--accent-cyan, #22d3ee);
      color: #0f172a;
      border: none;
      border-radius: 8px;
      padding: 8px 18px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      min-height: 36px;
      transition: opacity 0.15s;
    }
    .session-note-send:hover { opacity: 0.85; }

    /* Chat panel */
    #chatPanel {
      width: 300px;
      flex-shrink: 0;
      background: var(--surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: width 0.2s;
    }
    #chatPanel.collapsed {
      width: 0;
      overflow: hidden;
    }
    #chatMessages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #chatInputRow {
      padding: 8px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }
    #chatInput {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: rgba(255,255,255,0.04);
      color: var(--text);
      caret-color: var(--accent-cyan);
      font-size: 13px;
      outline: none;
    }
    #chatInput:focus { border-color: var(--accent-indigo); box-shadow: 0 0 0 3px rgba(129,140,248,0.15); }
    #sendChatBtn {
      background: var(--accent-grad);
      color: #080B12;
      border: none;
      border-radius: var(--radius);
      padding: 8px 16px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      box-shadow: 0 0 16px rgba(110,231,247,0.18);
    }
    #sendChatBtn:hover { box-shadow: 0 0 24px rgba(110,231,247,0.30); opacity: 0.92; }

    /* Chat bubbles */
    .chat-bubble {
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 13px;
      max-width: 85%;
      word-break: break-word;
    }
    .chat-bubble.me {
      background: var(--accent-grad);
      color: #080B12;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
      font-weight: 500;
    }
    .chat-bubble.them {
      background: var(--surface-high);
      backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      color: var(--text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .chat-bubble.system {
      background: none;
      color: var(--text-muted);
      font-size: 11px;
      align-self: center;
      font-style: italic;
    }
    .chat-bubble .meta {
      font-size: 10px;
      opacity: 0.5;
      margin-top: 2px;
      text-align: right;
    }
    .chat-bubble.them .meta { text-align: left; }

    /* Phase 68: message read receipt checkmark */
    .msg-receipt {
      font-size: 10px;
      margin-left: 4px;
      opacity: 0.6;
      vertical-align: bottom;
      color: var(--text-muted);
    }
    .msg-receipt.read {
      color: var(--accent, #06b6d4);
      opacity: 1;
    }

    /* Phase 68: typing indicator */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      font-size: 12px;
      color: var(--text-muted, rgba(255,255,255,0.45));
      min-height: 20px;
    }
    .typing-dots {
      display: inline-flex;
      gap: 3px;
      align-items: center;
    }
    .typing-dots span {
      display: block;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: var(--accent, #06b6d4);
      animation: typing-bounce 1.2s infinite ease-in-out;
    }
    .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing-bounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-4px); }
    }

    /* Control bar */
    #controlBar {
      height: 64px;
      background: rgba(8,11,18,0.85);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      flex-shrink: 0;
    }
    .ctrl-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 8px 12px;
      background: none;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      color: var(--text-sec);
      transition: background 0.15s, color 0.15s;
      min-width: 48px;
      height: 48px;
      justify-content: center;
    }
    .ctrl-btn:hover { background: var(--surface); color: var(--text); }
    .ctrl-btn.active { background: rgba(110,231,247,0.15); color: var(--accent-cyan); }
    /* Phase 70: Laser pointer â€” red glow when active */
    .ctrl-btn.laser-active { background: var(--danger-bg); color: var(--danger); border-color: var(--danger); animation: laser-pulse 1.5s ease-in-out infinite; }
    @keyframes laser-pulse {
      0%, 100% { box-shadow: 0 0 4px var(--danger); }
      50% { box-shadow: 0 0 10px var(--danger), 0 0 20px var(--danger); }
    }
    .ctrl-btn.danger { color: var(--danger); }
    .ctrl-btn.danger:hover { background: var(--danger-bg); }
    .ctrl-icon { font-size: 20px; line-height: 1; }
    .ctrl-label { font-size: 10px; font-weight: 500; }
    /* Phase 65: Settings launcher dropdown */
    .settings-launcher-group {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .settings-dropdown {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      background: var(--bg-card, #1e2a3a);
      border: 1px solid var(--border, rgba(255,255,255,0.15));
      border-radius: 10px;
      padding: 8px 0;
      min-width: 180px;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    .settings-dropdown-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.5;
      padding: 0 12px 6px;
      color: var(--text, inherit);
    }
    .settings-item {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
      background: none;
      border: none;
      color: var(--text, inherit);
      cursor: pointer;
      text-align: left;
      min-height: 36px;
      transition: background 0.1s;
    }
    .settings-item:hover, .settings-item:active {
      background: var(--hover, rgba(255,255,255,0.08));
    }
    /* Phase 71: Toolbar overflow drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #toolbarDrawer {
      position: fixed;
      bottom: 72px;        /* sits just above the 64px control bar */
      right: 8px;
      background: rgba(8,11,18,0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 6px;
      min-width: 200px;
      max-height: 70vh;
      overflow-y: auto;
      z-index: 400;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      /* hidden by default */
      opacity: 0;
      transform: translateY(8px);
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
    }
    #toolbarDrawer.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    .drawer-section-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.45;
      padding: 6px 10px 2px;
      color: var(--text);
    }
    .drawer-sep {
      height: 1px;
      background: var(--border);
      margin: 4px 6px;
    }
    .drawer-item {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      padding: 9px 12px;
      border: none;
      border-radius: 8px;
      background: transparent;
      color: var(--text-sec);
      cursor: pointer;
      font-size: 13px;
      text-align: left;
      min-height: 44px;
      transition: background 0.1s, color 0.1s;
      box-sizing: border-box;
    }
    .drawer-item:hover { background: rgba(110,231,247,0.08); color: var(--text); }
    .drawer-item.active { color: var(--accent-cyan); }
    .drawer-item.danger { color: var(--danger); }
    .drawer-item.danger:hover { background: var(--danger-bg); }
    .drawer-item-icon { font-size: 16px; flex-shrink: 0; }
    .drawer-item-label { flex: 1; }
    .drawer-shortcut {
      font-size: 10px;
      opacity: 0.45;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 1px 5px;
      font-family: monospace;
      flex-shrink: 0;
    }
    /* â”€â”€â”€ Nested settings items inside drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .drawer-settings-items {
      padding: 0 6px 4px;
    }
    .drawer-settings-items .settings-item {
      border-radius: 6px;
      font-size: 12px;
      min-height: 36px;
      padding: 6px 10px;
    }
    /* Phase 71: more button */
    #moreBtn { position: relative; }
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

    /* Phase 54: Elder mic level bars */
    .elder-mic-group {
      display: inline-flex;
      align-items: center;
      min-height: 48px;
      padding: 0 4px;
    }
    .elder-mic-bars {
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 14px;
    }
    .elder-mic-bar {
      width: 3px;
      height: 14px;
      border-radius: 2px;
      background: var(--border, rgba(255,255,255,0.2));
      transform-origin: bottom;
      transform: scaleY(0.15);
      transition: transform 0.1s ease-out, background 0.1s ease-out;
    }
    .elder-mic-bar.emb-low  { background: #22c55e; }
    .elder-mic-bar.emb-mid  { background: #eab308; }
    .elder-mic-bar.emb-high { background: #ef4444; }
    /* Phase 79: Elder Mic Level Panel (IPC-sourced RMS from Android) */
    #elderMicPanel {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      font-size: 12px;
      color: var(--text-muted);
      min-height: 24px;
    }
    .mic79-label { font-size: 12px; white-space: nowrap; color: var(--text-sec); }
    .mic79-track {
      width: 72px;
      height: 8px;
      background: var(--surface-high);
      border-radius: 4px;
      overflow: hidden;
    }
    .mic79-bar {
      height: 100%;
      width: 0%;
      background: var(--success);
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .mic79-bar.m79-warn    { background: var(--amber); }
    .mic79-bar.m79-clip    { background: var(--danger); }
    .mic79-status { font-size: 14px; line-height: 1; min-width: 16px; text-align: center; }
    /* Phase 54: Volume slider */
    .audio-volume-group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 48px;
      padding: 0 4px;
    }
    .volume-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      height: 4px;
      border-radius: 2px;
      background: var(--border, rgba(255,255,255,0.2));
      outline: none;
      cursor: pointer;
    }
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent, #06b6d4);
      cursor: pointer;
    }
    .volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent, #06b6d4);
      cursor: pointer;
      border: none;
    }
    .volume-label {
      font-size: 11px;
      min-width: 32px;
      font-variant-numeric: tabular-nums;
      opacity: 0.8;
    }
    /* Phase 51: Quality selector compact buttons */
    .quality-btn { min-width: 36px !important; padding: 4px 6px !important; opacity: 0.55; transition: opacity 0.15s; }
    .quality-btn.active { opacity: 1; }
    /* Phase 55: Session Recording */
    .ctrl-btn.recording { color: var(--danger); border-color: rgba(248,113,113,0.4); }
    .ctrl-btn.recording:hover { background: var(--danger-bg); }
    .rec-dot {
      display: inline-block;
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--danger);
      animation: rec-pulse 1s ease-in-out infinite;
      flex-shrink: 0;
    }
    @keyframes rec-pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.25; }
    }
    #recBadge {
      display: none;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--danger);
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    /* â”€â”€ Overlays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  */
    /* Paste panel */
    #pastePanel {
      display: none;
      position: fixed;
      top: 68px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 16px;
      z-index: 200;
      box-shadow: var(--shadow-xl);
      min-width: 320px;
      max-width: 90vw;
      flex-direction: column;
      gap: 10px;
    }
    #pastePanel .paste-title {
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
    }
    #pasteTextInput {
      width: 100%;
      background: rgba(255,255,255,0.04);
      color: var(--text);
      caret-color: var(--accent-cyan);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 10px;
      font-size: 14px;
      resize: vertical;
      font-family: inherit;
      outline: none;
    }
    #pasteTextInput:focus { border-color: var(--accent-indigo); box-shadow: 0 0 0 3px rgba(129,140,248,0.15); }
    .paste-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      align-items: center;
    }
    .paste-hint { color: var(--text-muted); font-size: 11px; flex: 1; }
    #pasteCancelBtn {
      padding: 7px 14px;
      background: var(--surface);
      color: var(--text-sec);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
    }
    #pasteSendBtn {
      padding: 7px 16px;
      background: var(--accent-grad);
      color: #080B12;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 0 16px rgba(110,231,247,0.18);
    }
    #pasteSendBtn:hover { box-shadow: 0 0 24px rgba(110,231,247,0.30); opacity: 0.92; }

    /* â”€â”€ Phase 60: Quick Message panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #quickMsgPanel {
      display: none;
      position: fixed;
      top: 68px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 16px;
      z-index: 200;
      box-shadow: var(--shadow-xl);
      min-width: 320px;
      max-width: 90vw;
      flex-direction: column;
      gap: 12px;
    }
    .quick-msg-title {
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
    }
    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .msg-chip {
      background: var(--surface);
      border: 1px solid var(--accent, #06b6d4);
      color: var(--on-surface, var(--text));
      padding: 5px 12px;
      border-radius: 16px;
      font-size: 13px;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.15s, opacity 0.15s;
    }
    .msg-chip:hover { background: rgba(6,182,212,0.12); }
    .msg-chip:active { opacity: 0.7; }
    .msg-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #quickMsgInput {
      flex: 1;
      background: rgba(255,255,255,0.04);
      color: var(--text);
      caret-color: var(--accent-cyan);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 9px 12px;
      font-size: 14px;
      font-family: inherit;
      outline: none;
    }
    #quickMsgInput:focus { border-color: var(--accent-indigo); box-shadow: 0 0 0 3px rgba(129,140,248,0.15); }
    .msg-send-btn {
      min-height: 48px;
      padding: 8px 16px;
      background: var(--accent, #06b6d4);
      color: #000;
      border: none;
      border-radius: var(--radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: opacity 0.15s;
      white-space: nowrap;
    }
    .msg-send-btn:hover { opacity: 0.88; }
    .quick-msg-actions {
      display: flex;
      justify-content: flex-end;
    }
    #quickMsgCancelBtn {
      padding: 7px 14px;
      background: transparent;
      color: var(--text-sec);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 13px;
      cursor: pointer;
      font-family: inherit;
    }
    #quickMsgCancelBtn:hover { background: rgba(255,255,255,0.06); }

    /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    @media (max-width: 600px) {
      #chatPanel { width: 260px; }
      #chatInput { font-size: 16px; }
      .ctrl-btn { min-width: 44px; height: 44px; padding: 6px; }
      .ctrl-label { display: none; }
      #controlBar { height: 52px; }
      #topBar { height: 48px; }
    }
    @media (max-width: 400px) {
      .connect-card { padding: 24px 20px; }
      #codeRow { gap: 8px; }
    }

    /* â”€â”€ Phase 59: Notification permission button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #notifRow {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 14px;
      padding: 10px 14px;
      background: var(--surface-low);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 13px;
      color: var(--text-sec);
    }
    #notifRow.notif-granted {
      border-color: rgba(110,231,247,0.2);
      background: rgba(110,231,247,0.06);
      color: var(--accent-cyan);
    }
    #notifRow.notif-denied {
      border-color: rgba(248,113,113,0.15);
      background: rgba(248,113,113,0.06);
      color: var(--text-muted);
    }
    #notifEnableBtn {
      margin-left: auto;
      padding: 5px 12px;
      background: var(--accent-grad);
      color: #080B12;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      flex-shrink: 0;
    }
    #notifEnableBtn:hover { opacity: 0.85; }
    /* Notification badge in top bar during session */
    #notifSessionBadge {
      display: none;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 3px 8px;
      font-size: 11px;
      color: var(--text-muted);
      cursor: default;
    }
    #notifSessionBadge.notif-on {
      background: rgba(110,231,247,0.08);
      color: var(--accent-cyan);
      border-color: rgba(110,231,247,0.2);
    }
    /* â”€â”€ Phase 66: Keyboard Shortcuts Guide Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #shortcutsModal {
      display: none;
      position: fixed; inset: 0; z-index: 999;
      background: rgba(0,0,0,0.82);
      align-items: center; justify-content: center;
      backdrop-filter: blur(4px);
    }
    .shortcuts-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px 28px;
      max-width: 380px;
      width: 92%;
      display: flex;
      flex-direction: column;
      gap: 0;
    }
    .shortcuts-card h3 {
      margin: 0 0 14px;
      font-size: 16px;
      color: var(--accent-cyan);
      font-weight: 600;
    }
    .shortcut-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      padding: 7px 0;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }
    .shortcut-row:last-of-type { border-bottom: none; margin-bottom: 14px; }
    .shortcut-key {
      font-family: monospace;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 5px;
      padding: 2px 8px;
      font-size: 11px;
      white-space: nowrap;
      flex-shrink: 0;
      color: var(--accent-cyan);
    }
    .shortcut-desc { color: var(--text-muted); }
    #shortcutsCloseBtn {
      background: rgba(110,231,247,0.08);
      color: var(--accent-cyan);
      border: 1px solid rgba(110,231,247,0.2);
      border-radius: 8px;
      padding: 9px 0;
      width: 100%;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    #shortcutsCloseBtn:hover { background: rgba(110,231,247,0.14); }
  </style>
  <!-- Phase 24: jsQR â€” browser QR code decoder (local + CDN fallback) -->
  <script src="jsqr.min.js" onerror="this.remove()"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
</head>
<body>

  <!-- â”€â”€ Phase 19: First-use tutorial overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="tutorialOverlay" style="
    display:none; position:fixed; inset:0; z-index:999;
    background:rgba(0,0,0,0.88); color:#fff;
    flex-direction:column; align-items:center; justify-content:center;
    padding:24px; text-align:center;
  ">
    <div style="max-width:420px;">
      <h2 style="background:linear-gradient(135deg,#6EE7F7,#818CF8);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text; margin:0 0 16px;">You're the Helper â€” Here's How</h2>
      <p style="line-height:1.6; color:rgba(240,244,255,0.65); margin:0 0 20px;">
        You're about to help a family member directly from your browser â€”
        no install needed. Here's how it works:
      </p>
      <div style="text-align:left; background:rgba(255,255,255,0.05); backdrop-filter:blur(20px); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:16px 20px; margin:0 0 24px;">
        <p style="margin:0 0 12px;">ğŸ“± <strong>Step 1:</strong> Ask them to open FamDesk and tap <em>"Get Help"</em>.</p>
        <p style="margin:0 0 12px;">ğŸ”¢ <strong>Step 2:</strong> They'll see an 8-letter code. Enter it below and click <em>"Connect"</em>.</p>
        <p style="margin:0 0 12px;">ğŸ–¥ï¸ <strong>Step 3:</strong> Their screen (or camera) will appear â€” you'll see exactly what they see.</p>
        <p style="margin:0;">ğŸ‘† <strong>Step 4:</strong> <em>Click or tap the screen</em> to place a glowing dot â€” they'll see it on their phone. Use the chat panel to type messages.</p>
      </div>
      <p style="color:rgba(240,244,255,0.35); font-size:12px; margin:0 0 20px;">
        ğŸ”’ This session is P2P encrypted. Only you and them see it â€” no servers in the middle.
      </p>
      <button id="tutorialDismissBtn" style="
        background:linear-gradient(135deg,#6EE7F7,#818CF8); color:#080B12; border:none; border-radius:12px;
        padding:12px 32px; font-size:16px; cursor:pointer; font-weight:600;
        box-shadow:0 0 24px rgba(110,231,247,0.25);
      ">I'm ready â€” let's go</button>
    </div>
  </div>

  <!-- â”€â”€ Phase 24: QR Scanner overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="qrScannerOverlay" style="
    display:none; position:fixed; inset:0; z-index:998;
    background:rgba(0,0,0,0.92); flex-direction:column;
    align-items:center; justify-content:center; gap:16px;
  ">
    <p style="color:#6EE7F7; font-size:16px; margin:0;">Point camera at the QR code on user's phone</p>
    <div style="position:relative; width:300px; height:300px;">
      <video id="qrVideo" style="width:300px; height:300px; object-fit:cover; border-radius:12px;" playsinline autoplay muted></video>
      <div style="
        position:absolute; inset:30px; border:2px solid #6EE7F7;
        border-radius:8px; pointer-events:none;
        box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5), 0 0 16px rgba(110,231,247,0.3);
      "></div>
    </div>
    <canvas id="qrCanvas" style="display:none;"></canvas>
    <p id="qrScanStatus" style="color:rgba(240,244,255,0.45); font-size:13px; margin:0;">Scanning...</p>
    <button id="qrCancelBtn" style="
      background:rgba(255,255,255,0.05); color:rgba(240,244,255,0.6); border:1px solid rgba(255,255,255,0.08);
      border-radius:8px; padding:8px 24px; cursor:pointer; font-size:14px; backdrop-filter:blur(20px);
    ">Cancel</button>
  </div>

  <!-- â”€â”€ Phase 66: Keyboard Shortcuts Guide Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="shortcutsModal">
    <div class="shortcuts-card">
      <h3>âŒ¨ï¸ Keyboard Shortcuts</h3>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ“¸ Save screenshot locally</span><kbd class="shortcut-key">S</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ“¤ Send screen snap to them</span><kbd class="shortcut-key">Shift+S</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ”‡ Mute / unmute mic</span><kbd class="shortcut-key">M</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ™ Mute / unmute their mic</span><kbd class="shortcut-key">Shift+M</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">â›¶ Toggle fullscreen</span><kbd class="shortcut-key">F</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ“‹ Paste text to their screen</span><kbd class="shortcut-key">P</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">âœï¸ Toggle annotation</span><kbd class="shortcut-key">A</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ“· Send reference image</span><kbd class="shortcut-key">I</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ”´ Toggle laser pointer</span><kbd class="shortcut-key">L</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸ“Š Toggle stream stats (FPS / queue / drops)</span><kbd class="shortcut-key">D</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">ğŸšª Cancel / close panels</span><kbd class="shortcut-key">Esc</kbd></div>
      <div class="shortcut-row"><span class="shortcut-desc">âŒ¨ï¸ Show this shortcuts guide</span><kbd class="shortcut-key">?</kbd></div>
      <button id="shortcutsCloseBtn">Close âœ•</button>
    </div>
  </div>

  <!-- â”€â”€ Connect UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="connectUI">
    <div class="connect-card">
      <h1>FamDesk</h1>
      <p class="tagline">Remote support â€” directly from your browser, no install needed.</p>

      <p id="status">Enter the 8-character code from the person who needs help.</p>

      <div id="codeRow">
        <button id="scanQrBtn" title="Point your camera at the QR code on the user's phone">ğŸ“· Scan QR Code</button>
        <div style="display:flex;align-items:center;gap:10px;color:var(--text-muted);font-size:13px">
          <div style="flex:1;height:1px;background:var(--border)"></div>
          <span>or type the code</span>
          <div style="flex:1;height:1px;background:var(--border)"></div>
        </div>
        <input id="codeInput" maxlength="8" placeholder="XXXXXXXX" autocomplete="off" spellcheck="false" />
        <button id="connectBtn">Connect</button>
      </div>

      <div id="howto">
        <h2>How it works</h2>
        <ol>
          <li>Ask the person you're helping to open FamDesk and tap <strong>"Get Help"</strong></li>
          <li>They'll see an 8-character code â€” enter it above</li>
          <li>Their screen appears here in a few seconds</li>
          <li>Voice is live â€” talk them through it</li>
          <li>Use the chat to type instructions</li>
        </ol>
      </div>

      <!-- Phase 59: Desktop notification permission -->
      <div id="notifRow">
        <span id="notifIcon">ğŸ””</span>
        <span id="notifText">Get notified when the session starts or they send a message.</span>
        <button id="notifEnableBtn">Enable</button>
      </div>
    </div>
  </div>

  <!-- â”€â”€ Session View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="sessionView">

    <!-- Top bar -->
    <div id="topBar">
      <span class="brand">FamDesk</span>
      <span id="versionBadge" style="font-size:11px;opacity:0.45;margin-left:6px;align-self:center"></span>

      <div class="session-info">
        <span id="connectionStatus">
          â— <span id="connectionStatusText">Waitingâ€¦</span>
        </span>
        <span id="sessionTimer">â± 00:00</span>
      </div>

      <div class="top-actions">
        <span id="fps" title="Screen share is capped at 15fps on the sender side for bandwidth efficiency. Camera stream is capped at 10fps.">-- fps</span>
        <span id="zoomBadge" title="Scroll to zoom Â· Double-click to reset">1x</span>
        <span id="latencyBadge" title="Round-trip latency">--ms</span>
        <!-- Phase 53: Stream Health Pill â€” frame age + bandwidth + auto-recovery indicator -->
        <div id="streamHealthPill" class="stream-health-pill" style="display:none" title="Stream health â€” frame age Â· bandwidth">
          <span id="healthIcon">ğŸŸ¢</span>
          <span id="frameAgeLabel">0ms</span>
          <span class="health-sep">Â·</span>
          <span id="bandwidthLabel">â€”</span>
        </div>
        <!-- Phase 54: Elder battery + network status badges -->
        <div id="batteryBadge" class="stream-health-pill" style="display:none" title="Elder's battery level">
          <span id="batteryIcon">ğŸ”‹</span>
          <span id="batteryLabel">â€”</span>
        </div>
        <div id="networkBadge" class="stream-health-pill" style="display:none" title="Elder's network connection">
          <span id="networkIcon">ğŸ“¶</span>
          <span id="networkLabel">â€”</span>
        </div>
        <!-- Phase 78: Camera torch state badge -->
        <span id="torchBadge" title="Elder's camera torch is ON" style="
          display:none; font-size:12px; padding:2px 8px; border-radius:10px;
          background:rgba(253,224,71,0.15); color:#fde047; border:1px solid rgba(253,224,71,0.3);
        ">ğŸ”† Torch ON</span>
        <!-- Phase 79: Elder Mic Level Panel â€” RMS from Android IPC -->
        <div id="elderMicPanel" style="display:none" class="stream-health-pill" title="Elder microphone level (real-time)">
          <span class="mic79-label">ğŸ¤ Elder</span>
          <div class="mic79-track">
            <div id="elderMicBar" class="mic79-bar"></div>
          </div>
          <span id="elderMicStatus" class="mic79-status">ğŸ”‡</span>
        </div>
                <!-- Phase 55: Recording indicator badge â€” pulsing red dot -->
        <div id="recBadge" title="Session recording in progress â€” auto-downloads on stop">
          <span class="rec-dot"></span><span>REC</span>
        </div>
        <span id="privacyBadge" title="This session is encrypted end-to-end using the NOISE protocol (same as Signal). Your ISP and any server only see encrypted bytes. Only you and the user see the screen.">ğŸ”’ P2P Â· NOISE encrypted</span>
        <!-- Phase 59: Notification status badge -->
        <span id="notifSessionBadge" title="Desktop notifications active â€” you'll be alerted if you switch tabs">ğŸ””</span>
        <button class="top-btn" id="chatToggleBtn">ğŸ’¬ Chat</button>
        <button id="disconnectBtn">âŒ End Session</button>
      </div>
    </div>

    <!-- Main area: screen + chat side by side -->
    <div id="mainArea">
      <div id="screenWrap">
        <canvas id="screen"></canvas>
        <canvas id="annotationCanvas"></canvas>
        <video id="helperCamPip" autoplay muted playsinline title="Your webcam â€” they can see your face"></video>
        <!-- Phase 36: hidden canvas for JPEG frame encoding (never shown) -->
        <canvas id="helperCamCanvas" style="display:none" width="320" height="240"></canvas>
        <button id="zoomResetBtn" title="Reset zoom (double-click canvas to zoom in/out)">ğŸ” Reset</button>
        <div id="pointerHint">ğŸ‘† Tap the screen to point â€” user sees a glowing dot</div>
        <div id="privacyNote">ğŸ”’ Passwords &amp; banking are private</div>
        <div id="streamMode">ğŸ–¥ï¸ Screen Share</div>
        <!-- Phase 81: Jitter buffer â€” underflow spinner + stream stats overlay -->
        <div id="bufferSpinner" style="display:none; position:absolute; top:8px; right:8px; z-index:25;
             background:rgba(0,0,0,0.65); color:var(--color-on-surface, #fff); font-size:12px;
             padding:4px 8px; border-radius:4px; pointer-events:none;">â³ bufferingâ€¦</div>
        <div id="streamStats" style="display:none; position:absolute; bottom:8px; left:8px; z-index:25;
             background:rgba(0,0,0,0.72); color:var(--color-on-surface, #fff); font-size:11px;
             font-family:monospace; padding:6px 10px; border-radius:4px;
             pointer-events:none; line-height:1.6;"></div>
        <!-- Phase 80: FLAG_SECURE privacy overlay â€” shown when elder opens banking/payment app -->
        <div id="privacyOverlay" style="display:none; position:absolute; inset:0; z-index:20;
             background:var(--surface-dim, rgba(0,0,0,0.88));
             flex-direction:column; align-items:center; justify-content:center;
             gap:12px; text-align:center; padding:24px; pointer-events:none;">
          <span style="font-size:40px;" aria-hidden="true">ğŸ”’</span>
          <p style="font-size:16px; font-weight:600; color:var(--color-on-surface, #fff); margin:0;">
            Privacy Protected
          </p>
          <p style="font-size:14px; color:var(--color-on-surface-muted, rgba(255,255,255,0.72)); margin:0; max-width:280px; line-height:1.5;">
            A sensitive screen is open â€” banking, passwords, or payment.<br>
            I can't see this content. I'll guide you by voice.
          </p>
          <p style="font-size:12px; color:var(--color-on-surface-muted, rgba(255,255,255,0.5)); margin:0; opacity:0.7;">
            This overlay disappears automatically when they navigate away.
          </p>
        </div>
      </div>

      <div id="chatPanel">
        <div id="chatMessages"></div>
        <!-- Phase 68: typing indicator â€” shown when elder is composing a message -->
        <div id="typingIndicator" class="typing-indicator" style="display:none">
          <span class="typing-dots"><span></span><span></span><span></span></span>
          <span id="typingLabel">User is typingâ€¦</span>
        </div>
        <div id="chatInputRow">
          <input id="chatInput" placeholder="Type a messageâ€¦ (Enter to send)" autocomplete="off" />
          <button id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>

    <!-- Control bar â€” Phase 71: primary strip (â‰¤7 items) + â‹® overflow drawer -->
    <div id="controlBar">
      <!-- Primary: always-visible controls -->
      <button class="ctrl-btn" id="muteBtn" title="Mute/unmute user's audio">
        <span class="ctrl-icon">ğŸ”Š</span><span class="ctrl-label">Audio</span>
      </button>
      <button class="ctrl-btn" id="micMuteBtn" title="Mute/unmute your microphone">
        <span class="ctrl-icon">ğŸ™ï¸</span><span class="ctrl-label">Mic</span>
      </button>
      <!-- Phase 37: VU meter â€” mic level indicator -->
      <div id="micVuWrap" style="display:none;flex-direction:column;align-items:center;gap:2px;padding:4px 6px;width:28px;height:48px;justify-content:center;pointer-events:none">
        <div id="micVuOuter" style="width:6px;height:30px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden;position:relative">
          <div id="micVuLevel" style="position:absolute;bottom:0;width:100%;height:0%;background:#22c55e;border-radius:3px;transition:height 0.05s ease,background 0.05s ease"></div>
        </div>
        <span style="font-size:8px;color:var(--text-sec);letter-spacing:0.3px">MIC</span>
      </div>
      <!-- Phase 54: Elder mic level bars + volume slider -->
      <div class="elder-mic-group" id="elderMicGroup" style="display:none"
           title="User's mic signal level â€” shows if audio is being received">
        <div class="elder-mic-bars" id="elderMicBars">
          <div class="elder-mic-bar" id="elderMicBar1"></div>
          <div class="elder-mic-bar" id="elderMicBar2"></div>
          <div class="elder-mic-bar" id="elderMicBar3"></div>
          <div class="elder-mic-bar" id="elderMicBar4"></div>
          <div class="elder-mic-bar" id="elderMicBar5"></div>
        </div>
      </div>
      <div class="audio-volume-group" id="audioVolumeGroup" style="display:none"
           title="User's microphone volume (0â€“150%)">
        <span class="ctrl-icon" style="font-size:13px">ğŸ”Š</span>
        <input type="range" id="volumeSlider" class="volume-slider"
               min="0" max="150" value="100" step="5"
               aria-label="User mic volume" />
        <span id="volumeLabel" class="volume-label">100%</span>
      </div>
      <!-- Primary: session controls -->
      <button class="ctrl-btn" id="annotateBtn" title="Toggle annotation drawing (A)">
        <span class="ctrl-icon">âœï¸</span><span class="ctrl-label">Draw</span>
      </button>
      <!-- Phase 70: Live Laser Pointer -->
      <button class="ctrl-btn" id="laserBtn" title="ğŸ”´ Laser pointer â€” move cursor to guide in real time (L)" style="display:none">
        <span class="ctrl-icon">ğŸ”´</span><span class="ctrl-label">Laser</span>
      </button>
      <!-- Primary: always visible -->
      <button class="ctrl-btn" id="fullscreenBtn" title="Fullscreen (F)">
        <span class="ctrl-icon">â›¶</span><span class="ctrl-label">Full</span>
      </button>
      <!-- Phase 78: High-res snapshot (camera mode only) -->
      <button class="ctrl-btn" id="snapBtn" title="Request a high-res still from elder's camera (camera mode only)" style="display:none">
        <span class="ctrl-icon">ğŸ“¸</span><span class="ctrl-label">Snap</span>
      </button>
      <!-- Phase 71: â‹® More â€” opens overflow drawer -->
      <button class="ctrl-btn" id="moreBtn" title="More tools (session controls, quality, recordingâ€¦)">
        <span class="ctrl-icon" style="font-size:22px;line-height:1">â‹®</span><span class="ctrl-label">More</span>
      </button>
    </div>

    <!-- Phase 71: Overflow drawer â€” secondary tools shown on â‹® click -->
    <div id="toolbarDrawer">
      <!-- Communication tools -->
      <div class="drawer-section-label">Send to device</div>
      <button class="drawer-item" id="pasteBtn" title="Send text to user's clipboard (P)">
        <span class="drawer-item-icon">ğŸ“‹</span>
        <span class="drawer-item-label">Paste text</span>
        <span class="drawer-shortcut">P</span>
      </button>
      <button class="drawer-item" id="quickMsgBtn" title="Send a text pop-up to user's screen (M)">
        <span class="drawer-item-icon">ğŸ’¬</span>
        <span class="drawer-item-label">Quick message</span>
        <span class="drawer-shortcut">M</span>
      </button>
      <button class="drawer-item" id="sendImageBtn" title="Send a reference image to user's screen (I)" style="display:none">
        <span class="drawer-item-icon">ğŸ“·</span>
        <span class="drawer-item-label">Send image</span>
        <span class="drawer-shortcut">I</span>
      </button>
      <input type="file" id="imageFileInput" accept="image/*" style="display:none">

      <!-- Settings launcher â€” nested items inline in drawer -->
      <div id="settingsLauncherGroup" style="display:none">
        <div class="drawer-sep"></div>
        <div class="drawer-section-label">Open on device</div>
        <div class="drawer-settings-items" id="settingsItemsContainer">
          <button class="settings-item" data-action="wifi">ğŸ“¶ WiFi</button>
          <button class="settings-item" data-action="bluetooth">ğŸ”µ Bluetooth</button>
          <button class="settings-item" data-action="cellular">ğŸ“¡ Mobile Data</button>
          <button class="settings-item" data-action="battery">ğŸ”‹ Battery Saver</button>
          <button class="settings-item" data-action="apps">ğŸ“± App Manager</button>
          <button class="settings-item" data-action="accessibility">â™¿ Accessibility</button>
          <button class="settings-item" data-action="display">ğŸ–¥ï¸ Display</button>
          <button class="settings-item" data-action="security">ğŸ”’ Security</button>
        </div>
      </div>

      <!-- Annotation -->
      <div class="drawer-sep"></div>
      <div class="drawer-section-label">Canvas</div>
      <button class="drawer-item danger" id="clearAnnotationsBtn" title="Clear all annotations">
        <span class="drawer-item-icon">ğŸ—‘ï¸</span>
        <span class="drawer-item-label">Clear annotations</span>
      </button>
      <button class="drawer-item" id="screenshotBtn" title="Save screenshot (S) Â· Shift+S sends snap to user">
        <span class="drawer-item-icon">ğŸ“¸</span>
        <span class="drawer-item-label">Screenshot</span>
        <span class="drawer-shortcut">S</span>
      </button>

      <!-- Stream tools -->
      <div class="drawer-sep"></div>
      <div class="drawer-section-label">Stream</div>
      <button class="drawer-item" id="helperCamBtn" title="Show your face to the user (requires HTTPS for mobile)" style="display:none">
        <span class="drawer-item-icon">ğŸ“¹</span>
        <span class="drawer-item-label">My camera</span>
      </button>
      <button class="drawer-item" id="helperScreenBtn" title="Share your screen (requires HTTPS)" style="display:none">
        <span class="drawer-item-icon">ğŸ“º</span>
        <span class="drawer-item-label">My screen</span>
      </button>
      <button class="drawer-item" id="refreshBtn" title="Refresh screen â€” clears frozen video" style="display:none">
        <span class="drawer-item-icon">ğŸ”„</span>
        <span class="drawer-item-label">Refresh screen</span>
      </button>
      <!-- Phase 51: quality selector -->
      <div class="ctrl-group" id="qualitySelector" style="display:none;padding:4px 12px;gap:4px;align-items:center" title="Stream quality">
        <span class="drawer-item-icon">ğŸ“Š</span>
        <span class="drawer-item-label" style="font-size:12px">Quality:</span>
        <button class="ctrl-btn quality-btn" id="qualLow" data-tier="LOW" title="Low (500 Kbps)" style="min-width:36px;height:32px;padding:4px"><span class="ctrl-icon" style="font-size:11px">ğŸ”½</span><span class="ctrl-label" style="font-size:9px">Low</span></button>
        <button class="ctrl-btn quality-btn active" id="qualMed" data-tier="MED" title="Medium (1 Mbps)" style="min-width:36px;height:32px;padding:4px"><span class="ctrl-icon" style="font-size:11px">â–</span><span class="ctrl-label" style="font-size:9px">Med</span></button>
        <button class="ctrl-btn quality-btn" id="qualHigh" data-tier="HIGH" title="High (2 Mbps)" style="min-width:36px;height:32px;padding:4px"><span class="ctrl-icon" style="font-size:11px">ğŸ”¼</span><span class="ctrl-label" style="font-size:9px">Hi</span></button>
      </div>
      <!-- Phase 55: Record session -->
      <button class="drawer-item" id="recBtn" title="Record session to local file â€” Chrome 120+ required" style="display:none">
        <span class="drawer-item-icon">âº</span>
        <span class="drawer-item-label">Record session</span>
        <span class="drawer-shortcut">R</span>
      </button>

      <!-- Utilities -->
      <div class="drawer-sep"></div>
      <button class="drawer-item" id="shortcutsHelpBtn" title="Keyboard shortcuts guide" style="display:none">
        <span class="drawer-item-icon">âŒ¨ï¸</span>
        <span class="drawer-item-label">Keyboard shortcuts</span>
        <span class="drawer-shortcut">?</span>
      </button>
      <button class="drawer-item" id="debugToggleBtn" title="Toggle debug log panel" style="display:none">
        <span class="drawer-item-icon">ğŸ›</span>
        <span class="drawer-item-label">Debug log</span>
      </button>
      <!-- Phase 86: PWA install button â€” shown only when browser fires beforeinstallprompt -->
      <button class="drawer-item" id="installPwaBtn" title="Install FamDesk Helper as a standalone app (Chrome/Edge)" style="display:none" onclick="installPwa()">
        <span class="drawer-item-icon">â¬‡</span>
        <span class="drawer-item-label">Install App</span>
      </button>
    </div>

    <!-- Phase 56: Debug log panel â€” shown when ?debug=1 or debug toggle active -->
    <div id="debugPanel" style="display:none; position:fixed; bottom:0; left:0; right:0; max-height:40vh; overflow-y:auto; background:rgba(0,0,0,0.92); color:#0f0; font:11px/1.4 monospace; padding:8px; z-index:9999; border-top:1px solid #0f04;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
        <span style="color:#0f0;font-weight:bold">ğŸ› FamDesk Debug Log</span>
        <span>
          <button onclick="document.getElementById('debugLog').textContent=''" style="background:transparent;border:1px solid #0f04;color:#0f0;padding:2px 8px;cursor:pointer;font:11px monospace;margin-right:4px">Clear</button>
          <button onclick="document.getElementById('debugPanel').style.display='none'" style="background:transparent;border:1px solid #0f04;color:#0f0;padding:2px 8px;cursor:pointer;font:11px monospace">âœ•</button>
        </span>
      </div>
      <pre id="debugLog" style="margin:0;white-space:pre-wrap;word-break:break-all;max-height:calc(40vh - 40px);overflow-y:auto"></pre>
    </div>

  </div><!-- /#sessionView -->

  <!-- Phase 34: Session summary toast â€” shown on session end -->
  <div id="sessionSummary"></div>

  <!-- Phase 74: Post-session how-to note card â€” shown after session ends -->
  <div id="sessionNoteCard" class="session-note-card" style="display:none">
    <div class="session-note-header">
      ğŸ“ Leave a how-to for your family member?
      <button class="session-note-dismiss" id="sessionNoteDismiss" title="Skip" aria-label="Dismiss how-to card">âœ•</button>
    </div>
    <textarea id="sessionNoteText"
      placeholder="e.g. To add a contact: 1. Open Phone app  2. Tap Contacts  3. Press +"
      maxlength="400"
      rows="4"></textarea>
    <div class="session-note-footer">
      <span class="session-note-charcount" id="noteCharCount">0/400</span>
      <button class="session-note-send" id="sessionNoteSend">Send Note ğŸ“¤</button>
    </div>
  </div>

  <!-- Hidden legacy statusBar â€” kept for JS compat, visually hidden -->
  <div id="statusBar" aria-hidden="true"></div>

  <!-- â”€â”€ Paste text panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="pastePanel">
    <div class="paste-title">ğŸ“‹ Send text to user's clipboard</div>
    <textarea id="pasteTextInput" placeholder="Type or paste text hereâ€¦ (Enter to send)" rows="3"></textarea>
    <div class="paste-actions">
      <span class="paste-hint">User can paste it anywhere on their phone.</span>
      <button id="pasteCancelBtn">Cancel</button>
      <button id="pasteSendBtn">Send â†’</button>
    </div>
  </div>

  <!-- â”€â”€ Phase 60: Quick Message panel â€” pop up a message on their screen â”€â”€ -->
  <div id="quickMsgPanel">
    <div class="quick-msg-title">ğŸ’¬ Message User's Screen</div>
    <div class="chip-row">
      <button class="msg-chip" data-msg="Please tap the Allow button">Tap Allow</button>
      <button class="msg-chip" data-msg="Swipe down from the top of your screen">Swipe Down</button>
      <button class="msg-chip" data-msg="Tap the blue button I'm pointing to">Tap Blue</button>
      <button class="msg-chip" data-msg="Wait a moment, I'm looking at your screen">Wait...</button>
      <button class="msg-chip" data-msg="You're doing great! Keep going.">Great job!</button>
    </div>
    <div class="msg-input-row">
      <input id="quickMsgInput" type="text" placeholder="Type a messageâ€¦ (Enter to send)" maxlength="120" autocomplete="off" />
      <button id="quickMsgSendBtn" class="msg-send-btn">Send ğŸ“¨</button>
    </div>
    <div class="quick-msg-actions">
      <button id="quickMsgCancelBtn">Close</button>
    </div>
  </div>

  <script>
    // â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Priority: ?gateway= URL param > auto-detect > LAN fallback
    // If served via HTTPS, ALWAYS use WSS â€” browsers block ws:// mixed content.
    // A ?gateway=ws://... param is silently upgraded to wss:// on the same host:port.
    const _urlParams = new URLSearchParams(window.location.search)
    const _rawGateway = _urlParams.get('gateway')

    // â”€â”€ Phase 56: Debug mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const DEBUG_MODE = _urlParams.get('debug') === '1'
    if (DEBUG_MODE) {
      document.getElementById('debugPanel').style.display = 'block'
      document.getElementById('debugToggleBtn').style.display = 'inline-flex'
    }
    document.getElementById('debugToggleBtn').addEventListener('click', () => {
      const panel = document.getElementById('debugPanel')
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none'
    })
    function appendDebugLog(tag, msg, ts) {
      const log = document.getElementById('debugLog')
      if (!log) return
      const time = new Date(ts || Date.now()).toISOString().slice(11, 23)
      log.textContent += `[${time}] [${tag}] ${msg}\n`
      log.scrollTop = log.scrollHeight
      // Also show toggle button once we get debug messages
      document.getElementById('debugToggleBtn').style.display = 'inline-flex'
    }

    const GATEWAY_WS = location.protocol === 'https:'
      ? (_rawGateway && _rawGateway.startsWith('wss://') ? _rawGateway : `wss://${location.hostname}:${location.port || 8443}`)
      : (_rawGateway || 'ws://192.168.1.252:4001')

    // â”€â”€ PWA Install Prompt (Phase 86) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let _deferredInstallPrompt = null

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault()
      _deferredInstallPrompt = e
      const btn = document.getElementById('installPwaBtn')
      if (btn) btn.style.display = 'inline-flex'
    })

    window.addEventListener('appinstalled', () => {
      _deferredInstallPrompt = null
      const btn = document.getElementById('installPwaBtn')
      if (btn) btn.style.display = 'none'
    })

    function installPwa() {
      if (!_deferredInstallPrompt) return
      _deferredInstallPrompt.prompt()
      _deferredInstallPrompt.userChoice.then(result => {
        if (result.outcome === 'accepted') {
          const btn = document.getElementById('installPwaBtn')
          if (btn) btn.style.display = 'none'
        }
        _deferredInstallPrompt = null
      })
    }

    // â”€â”€ Topic derivation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Must match MainActivity.kt: SHA-256("famdesk:" + CODE.toUpperCase())
    // Pure-JS SHA-256 â€” works on HTTP (crypto.subtle requires secure context)
    function sha256(msgBytes) {
      const K = [0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
                 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
                 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
                 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
                 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
                 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
                 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
                 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2]
      let h = [0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19]
      const l = msgBytes.length
      const bitLen = l * 8
      const padded = new Uint8Array(Math.ceil((l + 9) / 64) * 64)
      padded.set(msgBytes); padded[l] = 0x80
      const dv = new DataView(padded.buffer)
      dv.setUint32(padded.length - 4, bitLen >>> 0, false)
      dv.setUint32(padded.length - 8, Math.floor(bitLen / 0x100000000), false)
      const r = (n,b) => (n>>>b)|(n<<(32-b))
      for (let i = 0; i < padded.length; i += 64) {
        const w = new Uint32Array(64)
        for (let j = 0; j < 16; j++) w[j] = dv.getUint32(i + j * 4, false)
        for (let j = 16; j < 64; j++) {
          const s0 = r(w[j-15],7)^r(w[j-15],18)^(w[j-15]>>>3)
          const s1 = r(w[j-2],17)^r(w[j-2],19)^(w[j-2]>>>10)
          w[j] = (w[j-16]+s0+w[j-7]+s1) >>> 0
        }
        let [a,b,c,d,e,f,g,hh] = h
        for (let j = 0; j < 64; j++) {
          const S1 = r(e,6)^r(e,11)^r(e,25)
          const ch = (e&f)^(~e&g)
          const T1 = (hh+S1+ch+K[j]+w[j]) >>> 0
          const S0 = r(a,2)^r(a,13)^r(a,22)
          const maj = (a&b)^(a&c)^(b&c)
          const T2 = (S0+maj) >>> 0
          hh=g; g=f; f=e; e=(d+T1)>>>0; d=c; c=b; b=a; a=(T1+T2)>>>0
        }
        h = h.map((v,i)=>(v+[a,b,c,d,e,f,g,hh][i])>>>0)
      }
      const out = new Uint8Array(32)
      h.forEach((v,i) => new DataView(out.buffer).setUint32(i*4, v, false))
      return out
    }
    async function codeToTopicHex(code) {
      const enc  = new TextEncoder()
      const data = enc.encode('famdesk:' + code.toUpperCase())
      const hash = sha256(data)
      return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('')
    }

    // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const statusEl      = document.getElementById('status')
    // Version badge
    const _vb = document.getElementById('versionBadge')
    if (_vb && typeof FAMDESK_VERSION !== 'undefined') _vb.textContent = 'v' + FAMDESK_VERSION
    const codeInput     = document.getElementById('codeInput')
    const connectBtn    = document.getElementById('connectBtn')
    const disconnectBtn = document.getElementById('disconnectBtn')
    const connectUI     = document.getElementById('connectUI')
    const sessionView   = document.getElementById('sessionView')
    const canvas        = document.getElementById('screen')
    const ctx           = canvas.getContext('2d')
    const fpsEl         = document.getElementById('fps')
    const chatMessages  = document.getElementById('chatMessages')
    const chatInput     = document.getElementById('chatInput')

    // â”€â”€ Pre-fill code from URL param â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const urlCode = _urlParams.get('code') || ''
    if (urlCode) {
      codeInput.value = urlCode.toUpperCase()
      // Auto-connect unless ?auto=0 (allows manual review)
      if (_urlParams.get('auto') !== '0') {
        statusEl.textContent = 'ğŸ”— Link received â€” connectingâ€¦'
        setTimeout(() => {
          if (connectBtn && !connectBtn.disabled) connectBtn.click()
        }, 800)
      } else {
        statusEl.textContent = 'Code pre-filled from invite link â€” tap Connect when ready.'
      }
    }

    // â”€â”€ First-use tutorial overlay (Phase 19) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const TUTORIAL_KEY = 'famdesk_helper_tutorial_seen'
    const tutorialOverlay    = document.getElementById('tutorialOverlay')
    const tutorialDismissBtn = document.getElementById('tutorialDismissBtn')

    function maybeShowTutorial () {
      if (!localStorage.getItem(TUTORIAL_KEY)) {
        tutorialOverlay.style.display = 'flex'
      }
    }

    tutorialDismissBtn.addEventListener('click', () => {
      localStorage.setItem(TUTORIAL_KEY, '1')
      tutorialOverlay.style.display = 'none'
      // Auto-focus code input after dismiss
      document.getElementById('codeInput').focus()
    })

    // Show on load (after pre-fill logic runs so deep-link still works)
    maybeShowTutorial()

    // â”€â”€ Audio playback (Phase 8) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioCtx = null
    let audioGainNode = null   // Phase 54: GainNode for elder mic volume control
    let audioScheduledAt = 0
    const JITTER_BUFFER_MS = 200

    function getAudioCtx() {
      if (!audioCtx || audioCtx.state === 'closed') {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 })
        audioScheduledAt = 0
        audioGainNode = null  // reset â€” will be created in getAudioGainNode()
      }
      return audioCtx
    }

    // Phase 54: Get (or create) the GainNode for elder's incoming audio
    function getAudioGainNode() {
      const ctx = getAudioCtx()
      if (!audioGainNode) {
        audioGainNode = ctx.createGain()
        audioGainNode.gain.value = (parseInt(document.getElementById('volumeSlider').value, 10) || 100) / 100
        audioGainNode.connect(ctx.destination)
      }
      return audioGainNode
    }

    function playPcm16(base64, sampleRate) {
      const ctx = getAudioCtx()
      // Resume context if browser suspended it (happens on mobile after backgrounding,
      // or if AudioContext was created before the first user gesture in some browsers).
      // Without this, scheduling audio on a suspended context silently drops all chunks.
      if (ctx.state === 'suspended') {
        ctx.resume().catch(() => {})
        // Reset schedule cursor so we don't play a massive backlog after resume
        audioScheduledAt = 0
      }
      // Decode base64 â†’ raw bytes
      const raw = atob(base64)
      const bytes = new Uint8Array(raw.length)
      for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i)
      // Convert PCM16 LE â†’ Float32 [-1, 1]
      const samples = bytes.length / 2
      const float32 = new Float32Array(samples)
      const view = new DataView(bytes.buffer)
      for (let i = 0; i < samples; i++) {
        float32[i] = view.getInt16(i * 2, true) / 32768.0
      }
      // Create AudioBuffer
      const buf = ctx.createBuffer(1, samples, sampleRate)
      buf.copyToChannel(float32, 0)
      // Schedule with jitter buffer
      const now = ctx.currentTime
      const chunkDuration = samples / sampleRate
      if (audioScheduledAt < now + 0.010) {
        audioScheduledAt = now + (JITTER_BUFFER_MS / 1000)
      }
      const src = ctx.createBufferSource()
      src.buffer = buf
      src.connect(getAudioGainNode())  // Phase 54: through GainNode (volume control)
      src.start(audioScheduledAt)
      audioScheduledAt += chunkDuration
      // Phase 54: compute RMS from raw samples for mic level bars
      updateElderMicBarsWithDecay(computeElderRms(float32))
    }

    // â”€â”€ WebCodecs H.264 VideoDecoder (Phase 32) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let videoDecoder = null
    let videoDecoderInit = false   // true once codec_init received
    let videoDecoderConfig = null  // {codec, width, height, sps, pps}
    let renderPending = false

    // â”€â”€ Phase 81: Video Jitter Buffer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const JITTER_MAX        = 6
    const JITTER_TARGET_FPS = 15
    const JITTER_FRAME_MS   = 1000 / JITTER_TARGET_FPS   // 66.7ms
    const jitterQueue       = []     // ring buffer of ImageBitmap objects
    let jitterRendered      = 0
    let jitterDropped       = 0
    let jitterLastFrameMs   = 0
    let jitterRafId         = null
    let jitterRafAcc        = 0
    let jitterRafLastTs     = 0
    let jitterSpinnerShown  = false
    let jitterStatsVisible  = false
    let jitterFpsCount      = 0
    let jitterFpsMark       = 0
    let jitterCurrentFps    = 0

    // Annex B SPS+PPS prefix prepended to every keyframe so the decoder always
    // receives codec parameters right before the IDR slice, regardless of whether
    // the Android encoder includes them in the IDR frame output or not.
    let h264SpsPpsPrefix = null

    function initVideoDecoder(config) {
      console.log('[WebCodecs] initVideoDecoder called â€” config:', JSON.stringify({codec:config.codec,width:config.width,height:config.height,hasSps:!!config.sps,hasPps:!!config.pps}))
      if (typeof VideoDecoder === 'undefined') {
        console.warn('[WebCodecs] VideoDecoder not available, staying on JPEG')
        return
      }
      if (videoDecoder) { try { videoDecoder.close() } catch(_) {} }
      videoDecoder = new VideoDecoder({
        output: (frame) => {
          // Phase 81: push decoded frame to jitter buffer (via ImageBitmap) instead of direct draw
          const frameW     = frame.displayWidth
          const frameH     = frame.displayHeight
          const frameBytes = frame.allocationSize ? frame.allocationSize() : 0
          createImageBitmap(frame).then(bitmap => {
            bitmap._w     = frameW
            bitmap._h     = frameH
            bitmap._bytes = frameBytes
            if (jitterQueue.length >= JITTER_MAX) {
              const dropped = jitterQueue.shift()
              try { dropped.close() } catch(_) {}
              jitterDropped++
            }
            jitterQueue.push(bitmap)
            if (!sessionViewShown) {
              sessionViewShown = true
              showSessionView()
              setStatus('\u2705 Connected (H.264)', 'connected')
              appendChat('Session started \u2014 say hello!', 'system')
            }
          }).catch(() => {})
          frame.close()
          renderPending = false
        },
        error: (err) => {
          console.error('[WebCodecs] VideoDecoder error:', err)
          videoDecoder = null
          videoDecoderInit = false
          h264SpsPpsPrefix = null
        }
      })

      const codec = config.sps
        ? buildAvcCodecString(config.sps)
        : 'avc1.42E01E'

      // Byte-stream mode (no description): decoder expects raw Annex B with start codes.
      // Simpler and more reliable than AVCC mode â€” no format conversion needed.
      // We manually prepend SPS+PPS (Annex B) to every keyframe so the decoder
      // always has codec parameters before the IDR slice.
      videoDecoder.configure({
        codec,
        codedWidth: config.width,
        codedHeight: config.height
        // no description â†’ byte-stream mode
      })

      if (config.sps && config.pps) {
        const spsRaw = stripAnnexBStartCode(Uint8Array.from(atob(config.sps), c => c.charCodeAt(0)))
        const ppsRaw = stripAnnexBStartCode(Uint8Array.from(atob(config.pps), c => c.charCodeAt(0)))
        const startCode = new Uint8Array([0, 0, 0, 1])
        const prefix = new Uint8Array(startCode.length + spsRaw.length + startCode.length + ppsRaw.length)
        let off = 0
        prefix.set(startCode, off); off += startCode.length
        prefix.set(spsRaw,    off); off += spsRaw.length
        prefix.set(startCode, off); off += startCode.length
        prefix.set(ppsRaw,    off)
        h264SpsPpsPrefix = prefix
        console.log('[WebCodecs] SPS+PPS prefix built:', prefix.length, 'bytes')
      }

      videoDecoderConfig = config
      videoDecoderInit = true
      console.log('[WebCodecs] VideoDecoder configured (byte-stream):', codec, config.width, 'x', config.height)
      startVideoRenderLoop()   // Phase 81: begin 15fps jitter-buffer render loop
    }

    // Strip Annex B start code (4-byte 00 00 00 01 or 3-byte 00 00 01) from a NALU.
    // Returns a subarray starting at the first real NALU byte (e.g. 0x67 for SPS).
    // Handles both variants correctly; returns the original array if no start code present.
    function stripAnnexBStartCode(data) {
      if (data.length >= 4 && data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 1)
        return data.subarray(4)  // 4-byte start code
      if (data.length >= 3 && data[0] === 0 && data[1] === 0 && data[2] === 1)
        return data.subarray(3)  // 3-byte start code
      return data               // no start code â€” raw NALU already
    }

    function buildAvcDecoderConfig(spsB64, ppsB64) {
      const sps = Uint8Array.from(atob(spsB64), c => c.charCodeAt(0))
      const pps = Uint8Array.from(atob(ppsB64), c => c.charCodeAt(0))
      const spsRaw = stripAnnexBStartCode(sps)
      const ppsRaw = stripAnnexBStartCode(pps)
      const buf = new Uint8Array([
        1,                          // configurationVersion
        spsRaw[1],                  // AVCProfileIndication
        spsRaw[2],                  // profile_compatibility
        spsRaw[3],                  // AVCLevelIndication
        0xff,                       // lengthSizeMinusOne (4-byte)
        0xe1,                       // numSequenceParameterSets
        (spsRaw.length >> 8) & 0xff,
        spsRaw.length & 0xff,
        ...spsRaw,
        1,                          // numPictureParameterSets
        (ppsRaw.length >> 8) & 0xff,
        ppsRaw.length & 0xff,
        ...ppsRaw
      ])
      return buf.buffer
    }

    function buildAvcCodecString(spsB64) {
      const sps = Uint8Array.from(atob(spsB64), c => c.charCodeAt(0))
      const raw = stripAnnexBStartCode(sps)
      if (raw.length < 4) return 'avc1.42E01E'
      return 'avc1.' + [raw[1], raw[2], raw[3]].map(b => b.toString(16).padStart(2,'0')).join('')
    }

    // Convert Annex B byte stream (Android MediaCodec output) to AVCC (WebCodecs input).
    // Annex B: each NALU preceded by 3- or 4-byte start code (0x00 0x00 [0x00] 0x01).
    // AVCC:    each NALU preceded by 4-byte big-endian length (no start code).
    // Required because WebCodecs VideoDecoder configured with description= expects AVCC.
    function annexBToAvcc(src) {
      const out = []
      let i = 0
      while (i < src.length) {
        // Detect start code
        let startLen = 0
        if (i + 3 < src.length && src[i] === 0 && src[i+1] === 0 && src[i+2] === 0 && src[i+3] === 1) startLen = 4
        else if (i + 2 < src.length && src[i] === 0 && src[i+1] === 0 && src[i+2] === 1) startLen = 3
        else { i++; continue }

        const naluStart = i + startLen
        // Find next start code (= end of this NALU)
        let naluEnd = src.length
        for (let j = naluStart + 1; j < src.length - 2; j++) {
          if (src[j] === 0 && src[j+1] === 0) {
            if (src[j+2] === 1) { naluEnd = j; break }
            if (j + 3 < src.length && src[j+2] === 0 && src[j+3] === 1) { naluEnd = j; break }
          }
        }
        const len = naluEnd - naluStart
        out.push((len >>> 24) & 0xff, (len >>> 16) & 0xff, (len >>> 8) & 0xff, len & 0xff)
        for (let k = naluStart; k < naluEnd; k++) out.push(src[k])
        i = naluEnd
      }
      return new Uint8Array(out)
    }

    // Real-time H.264 decoding: drop frames when decoder queue is backed up.
    // MAX_H264_QUEUE = 2 keeps at most 2 frames in flight; surplus delta frames
    // are dropped so the browser always shows the most recent frame, not old ones.
    const MAX_H264_QUEUE = 2

    function decodeH264Frame(msg) {
      if (!videoDecoder || videoDecoder.state === 'closed') return
      // Real-time drop: skip delta frames when decoder is backed up
      if (videoDecoder.decodeQueueSize >= MAX_H264_QUEUE && !msg.keyframe) return
      try {
        const raw = Uint8Array.from(atob(msg.data), c => c.charCodeAt(0))
        // Byte-stream mode: pass raw Annex B directly to the decoder.
        // For keyframes, prepend the stored SPS+PPS so the decoder always has
        // codec parameters immediately before the IDR slice.
        let data = raw
        if (msg.keyframe) {
          if (h264SpsPpsPrefix) {
            const combined = new Uint8Array(h264SpsPpsPrefix.length + raw.length)
            combined.set(h264SpsPpsPrefix, 0)
            combined.set(raw, h264SpsPpsPrefix.length)
            data = combined
            if (!window._keyframeCount) window._keyframeCount = 0
            if (++window._keyframeCount <= 3) console.log('[WebCodecs] keyframe #' + window._keyframeCount + ' with SPS+PPS prefix, total:', data.length, 'bytes')
          } else {
            console.warn('[WebCodecs] keyframe received but h264SpsPpsPrefix is null â€” dropping (no codec_init yet)')
            return
          }
        }
        renderPending = true
        videoDecoder.decode(new EncodedVideoChunk({
          type: msg.keyframe ? 'key' : 'delta',
          timestamp: (msg.pts || 0) * 1000, // microseconds
          data: data
        }))
      } catch (e) {
        renderPending = false
        console.warn('[WebCodecs] decode error:', e.message)
      }
    }

    // â”€â”€ Phase 81: Jitter Buffer Render Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startVideoRenderLoop() {
      if (jitterRafId) return
      jitterRafLastTs = performance.now()
      jitterRafAcc    = 0
      jitterFpsMark   = performance.now()
      jitterFpsCount  = 0
      jitterRafId     = requestAnimationFrame(jitterRenderTick)
    }

    function stopVideoRenderLoop() {
      if (jitterRafId) { cancelAnimationFrame(jitterRafId); jitterRafId = null }
      jitterQueue.forEach(b => { try { b.close() } catch(_) {} })
      jitterQueue.length  = 0
      jitterRendered      = 0
      jitterDropped       = 0
      jitterCurrentFps    = 0
      jitterSpinnerShown  = false
      jitterLastFrameMs   = 0
      const spinner = document.getElementById('bufferSpinner')
      if (spinner) spinner.style.display = 'none'
      const stats = document.getElementById('streamStats')
      if (stats) stats.style.display = 'none'
      jitterStatsVisible = false
    }

    function jitterRenderTick(now) {
      jitterRafId = requestAnimationFrame(jitterRenderTick)
      const delta  = now - jitterRafLastTs
      jitterRafLastTs = now
      jitterRafAcc   += delta
      if (jitterRafAcc < JITTER_FRAME_MS) return
      jitterRafAcc   -= JITTER_FRAME_MS

      if (jitterQueue.length > 0) {
        const bitmap = jitterQueue.shift()
        const c = document.getElementById('screen')
        if (c) {
          const cctx = c.getContext('2d')
          if (bitmap._w && (c.width !== bitmap._w || c.height !== bitmap._h)) {
            c.width = bitmap._w
            c.height = bitmap._h
            syncAnnotCanvasSize()
          }
          cctx.drawImage(bitmap, 0, 0)
        }
        try { bitmap.close() } catch(_) {}
        jitterRendered++
        tickFps()
        if (bitmap._bytes) onFrameReceived(bitmap._bytes)
        jitterLastFrameMs = now
        // Hide spinner
        if (jitterSpinnerShown) {
          jitterSpinnerShown = false
          const spinner = document.getElementById('bufferSpinner')
          if (spinner) spinner.style.display = 'none'
        }
        // FPS tracking
        jitterFpsCount++
        if (now - jitterFpsMark >= 1000) {
          jitterCurrentFps = jitterFpsCount
          jitterFpsCount   = 0
          jitterFpsMark    = now
        }
        if (jitterStatsVisible) updateJitterStats()
      } else {
        // Underflow â€” freeze on last frame; show spinner after 500ms
        if (!jitterSpinnerShown && jitterLastFrameMs > 0 && (now - jitterLastFrameMs) > 500) {
          jitterSpinnerShown = true
          const spinner = document.getElementById('bufferSpinner')
          if (spinner) spinner.style.display = 'block'
        }
      }
    }

    function updateJitterStats() {
      const el = document.getElementById('streamStats')
      if (!el || !jitterStatsVisible) return
      el.innerHTML =
        `FPS: ${jitterCurrentFps}/${JITTER_TARGET_FPS}<br>` +
        `Queue: ${jitterQueue.length}/${JITTER_MAX}<br>` +
        `Rendered: ${jitterRendered}<br>` +
        `Dropped: ${jitterDropped}`
    }

    // â”€â”€ WebCodecs AAC AudioDecoder (Phase 32) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioDecoderWC = null   // "WC" suffix to avoid clash with existing vars
    let audioDecoderInit = false

    function initAudioDecoder(config) {
      if (typeof AudioDecoder === 'undefined') {
        console.warn('[WebCodecs] AudioDecoder not available, staying on PCM16')
        return
      }
      if (audioDecoderWC) { try { audioDecoderWC.close() } catch(_) {} }
      audioDecoderWC = new AudioDecoder({
        output: (audioData) => {
          const actx = getAudioCtx()
          if (actx.state === 'suspended') { actx.resume().catch(()=>{}) }
          const numChannels = audioData.numberOfChannels
          const numFrames = audioData.numberOfFrames
          const buf = actx.createBuffer(numChannels, numFrames, audioData.sampleRate)
          for (let ch = 0; ch < numChannels; ch++) {
            const dest = buf.getChannelData(ch)
            audioData.copyTo(dest, { planeIndex: ch, format: 'f32' })
          }
          const src = actx.createBufferSource()
          src.buffer = buf
          src.connect(getAudioGainNode())  // Phase 54: through GainNode (volume control)
          const now = actx.currentTime
          if (audioScheduledAt < now + 0.010) audioScheduledAt = now + 0.010
          src.start(audioScheduledAt)
          audioScheduledAt += buf.duration
          // Phase 54: compute RMS from decoded float32 (channel 0)
          updateElderMicBarsWithDecay(computeElderRms(buf.getChannelData(0)))
          audioData.close()
        },
        error: (err) => {
          console.warn('[WebCodecs] AudioDecoder error:', err)
          audioDecoderWC = null
          audioDecoderInit = false
        }
      })
      audioDecoderWC.configure({
        codec: 'mp4a.40.2', // AAC-LC
        sampleRate: config.sampleRate || 16000,
        numberOfChannels: config.channelCount || 1
      })
      audioDecoderInit = true
      console.log('[WebCodecs] AudioDecoder configured (AAC-LC)')
    }

    // â”€â”€ Phase 54: Elder Audio Controls (Volume Slider + Mic Level Bars) â”€â”€â”€â”€â”€â”€â”€â”€
    const ELDER_MIC_BARS = document.querySelectorAll('.elder-mic-bar')
    const ELDER_BAR_THRESHOLDS = [0.02, 0.06, 0.12, 0.22, 0.40]
    let elderLastRms = 0
    let elderMicDecayTimer = null

    function computeElderRms(float32Array) {
      if (!float32Array || float32Array.length === 0) return 0
      let sum = 0
      for (let i = 0; i < float32Array.length; i++) {
        const s = float32Array[i]
        sum += s * s
      }
      return Math.sqrt(sum / float32Array.length)
    }

    function updateElderMicBars(rms) {
      ELDER_MIC_BARS.forEach((bar, i) => {
        const active = rms > ELDER_BAR_THRESHOLDS[i]
        const isHigh = i >= 3
        const isMid  = i === 2
        bar.style.transform = active ? `scaleY(${0.4 + i * 0.15})` : 'scaleY(0.15)'
        bar.classList.toggle('emb-high', active && isHigh)
        bar.classList.toggle('emb-mid',  active && isMid && !isHigh)
        bar.classList.toggle('emb-low',  active && !isMid && !isHigh)
      })
    }

    function updateElderMicBarsWithDecay(rms) {
      elderLastRms = Math.max(rms, elderLastRms * 0.85)
      updateElderMicBars(elderLastRms)
    }

    function startElderMicDecay() {
      if (elderMicDecayTimer) clearInterval(elderMicDecayTimer)
      elderMicDecayTimer = setInterval(() => updateElderMicBarsWithDecay(0), 100)
    }

    function stopElderMicDecay() {
      if (elderMicDecayTimer) { clearInterval(elderMicDecayTimer); elderMicDecayTimer = null }
      updateElderMicBars(0)
      elderLastRms = 0
    }

    // Volume slider
    const volumeSlider = document.getElementById('volumeSlider')
    const volumeLabel  = document.getElementById('volumeLabel')
    volumeSlider.addEventListener('input', () => {
      const pct = parseInt(volumeSlider.value, 10)
      volumeLabel.textContent = pct + '%'
      if (audioGainNode && audioCtx) {
        audioGainNode.gain.setTargetAtTime(pct / 100, audioCtx.currentTime, 0.05)
      }
    })

    // Mute button
    let muted = false
    const muteBtn = document.getElementById('muteBtn')
    muteBtn.addEventListener('click', () => {
      muted = !muted
      muteBtn.querySelector('.ctrl-icon').textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š'
      muteBtn.classList.toggle('active', muted)
      if (audioCtx) {
        if (muted) audioCtx.suspend()
        else audioCtx.resume()
      }
    })

    // â”€â”€ Phase 55: Session Recording â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let recorder          = null
    let recChunks         = []
    let recTimerInterval  = null
    let recStartMs        = 0
    let recAudioDest      = null

    function startRecording () {
      if (typeof MediaRecorder === 'undefined') {
        appendStatus('âº MediaRecorder not available (Chrome 120+ required)', 'warn')
        return
      }
      if (recorder && recorder.state === 'recording') { stopRecording(); return }
      const canvas = document.getElementById('screen')
      if (!canvas) { appendStatus('âº Canvas not ready', 'warn'); return }

      // Video: capture canvas at 10fps
      const canvasStream = canvas.captureStream(10)
      const tracks = [...canvasStream.getVideoTracks()]

      // Audio: tap off audioGainNode (elder's incoming audio, volume-adjusted)
      try {
        const ctx = getAudioCtx()
        recAudioDest = ctx.createMediaStreamDestination()
        getAudioGainNode().connect(recAudioDest)
        tracks.push(...recAudioDest.stream.getAudioTracks())
      } catch (_) {
        recAudioDest = null // audio not available â€” record video-only
      }

      const combined = new MediaStream(tracks)
      const mimeType =
        MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') ? 'video/webm;codecs=vp9,opus' :
        MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus') ? 'video/webm;codecs=vp8,opus' :
        'video/webm'

      recChunks = []
      recorder = new MediaRecorder(combined, { mimeType, videoBitsPerSecond: 500_000 })

      recorder.ondataavailable = e => { if (e.data && e.data.size > 0) recChunks.push(e.data) }
      recorder.onstop = () => {
        // Disconnect audio tap
        if (recAudioDest) {
          try { getAudioGainNode().disconnect(recAudioDest) } catch (_) {}
          recAudioDest = null
        }
        if (recChunks.length === 0) return
        const blob = new Blob(recChunks, { type: mimeType })
        const url  = URL.createObjectURL(blob)
        const a    = Object.assign(document.createElement('a'), {
          download: 'famdesk-' + new Date().toISOString().replace(/[:.]/g,'-').slice(0,19) + '.webm',
          href: url
        })
        document.body.appendChild(a); a.click(); document.body.removeChild(a)
        setTimeout(() => URL.revokeObjectURL(url), 5000)
        recChunks = []
      }

      recorder.start(1000) // collect in 1-second chunks
      recStartMs = Date.now()

      // Show pulsing badge
      const badge = document.getElementById('recBadge')
      if (badge) badge.style.display = 'inline-flex'

      // Update button â†’ red â¹ + elapsed timer
      const btn = document.getElementById('recBtn')
      if (btn) {
        btn.classList.add('recording')
        btn.querySelector('.ctrl-icon').textContent = 'â¹'
        btn.querySelector('.ctrl-label').textContent = '0:00'
        btn.title = 'Stop recording and download'
      }

      recTimerInterval = setInterval(() => {
        const s = Math.floor((Date.now() - recStartMs) / 1000)
        const mm = Math.floor(s / 60).toString().padStart(2,'0')
        const ss = (s % 60).toString().padStart(2,'0')
        const b = document.getElementById('recBtn')
        if (b) b.querySelector('.ctrl-label').textContent = mm + ':' + ss
      }, 1000)

      appendStatus('âº Recording started', 'info')
    }

    function stopRecording () {
      if (recTimerInterval) { clearInterval(recTimerInterval); recTimerInterval = null }

      const badge = document.getElementById('recBadge')
      if (badge) badge.style.display = 'none'

      const btn = document.getElementById('recBtn')
      if (btn) {
        btn.classList.remove('recording')
        btn.querySelector('.ctrl-icon').textContent = 'âº'
        btn.querySelector('.ctrl-label').textContent = 'Rec'
        btn.title = 'Record session to local file (â¹ to stop + auto-download) â€” Chrome 120+ required'
      }

      if (recorder) {
        if (recorder.state === 'recording') recorder.stop() // triggers onstop â†’ download
        else if (recAudioDest) {
          try { getAudioGainNode().disconnect(recAudioDest) } catch (_) {}
          recAudioDest = null
        }
        recorder = null
      }
    }

    // Wire record button
    document.getElementById('recBtn').addEventListener('click', () => {
      if (recorder && recorder.state === 'recording') stopRecording()
      else startRecording()
    })

    // â”€â”€ Browser Mic Capture (Phase 10) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let micProcessor = null
    let micSource    = null
    let micMuted     = false
    const micMuteBtn = document.getElementById('micMuteBtn')

    function startBrowserMic(wsConn) {
      if (!window._micStream) return   // permission denied or not available
      const stream = window._micStream

      const actx = getAudioCtx()
      if (actx.state === 'suspended') actx.resume()

      micSource = actx.createMediaStreamSource(stream)

      // ScriptProcessor: 1024 samples â€” ~64ms chunks at 16kHz, less overhead than smaller sizes
      // Deprecated but still the most compatible path (AudioWorklet adds complexity)
      micProcessor = actx.createScriptProcessor(1024, 1, 1)

      micProcessor.onaudioprocess = (e) => {
        if (!wsConn || wsConn.readyState !== WebSocket.OPEN) return
        const f32 = e.inputBuffer.getChannelData(0)

        // Downsample to 16kHz: Chrome commonly gives 48kHz even when 16kHz is requested
        const nativeSR = actx.sampleRate     // e.g. 16000 or 48000
        const targetSR = 16000
        const step     = nativeSR / targetSR // 1.0 at 16kHz, 3.0 at 48kHz

        const outLen = Math.floor(f32.length / step)
        const pcm16  = new Int16Array(outLen)
        for (let i = 0; i < outLen; i++) {
          const s = f32[Math.floor(i * step)]
          pcm16[i] = Math.max(-32768, Math.min(32767, Math.round(s * 32768)))
        }

        // Base64 encode the PCM16 bytes
        const bytes = new Uint8Array(pcm16.buffer)
        let b64 = ''
        for (let i = 0; i < bytes.length; i++) b64 += String.fromCharCode(bytes[i])
        b64 = btoa(b64)

        wsConn.send(JSON.stringify({ type: 'audio', data: b64, source: 'helper', sampleRate: targetSR }) + '\n')
      }

      // Connect: source â†’ processor â†’ destination (destination required to keep processor alive in Chrome)
      micSource.connect(micProcessor)
      micProcessor.connect(actx.destination)

      // Phase 37: VU meter â€” AnalyserNode taps micSource in parallel (silent sink, no echo)
      const vuAnalyser = actx.createAnalyser()
      vuAnalyser.fftSize = 256
      const vuSink = actx.createGain()
      vuSink.gain.value = 0  // silent â€” just keeps analyser in the active graph
      micSource.connect(vuAnalyser)
      vuAnalyser.connect(vuSink)
      vuSink.connect(actx.destination)
      window._micVuAnalyser = vuAnalyser
      window._micVuSink    = vuSink

      const vuData  = new Uint8Array(vuAnalyser.frequencyBinCount)
      const vuWrap  = document.getElementById('micVuWrap')
      const vuLevel = document.getElementById('micVuLevel')
      if (vuWrap) vuWrap.style.display = 'flex'
      let vuActive = true

      function drawVu() {
        if (!vuActive) return
        vuAnalyser.getByteTimeDomainData(vuData)
        let peak = 0
        for (let i = 0; i < vuData.length; i++) peak = Math.max(peak, Math.abs(vuData[i] - 128))
        const level = peak / 128  // 0.0-1.0
        if (vuLevel) {
          vuLevel.style.height = Math.round(level * 100) + '%'
          vuLevel.style.background = level < 0.8 ? '#22c55e' : level < 0.95 ? '#f59e0b' : '#ef4444'
        }
        window._micVuRafId = requestAnimationFrame(drawVu)
      }
      drawVu()
      window._micVuStop = () => { vuActive = false }

      console.log('[browser-mic] Mic capture started at', actx.sampleRate, 'Hz (AEC+NS+AGC, VU active)')
    }

    function stopBrowserMic() {
      if (micProcessor) { micProcessor.disconnect(); micProcessor = null }
      if (micSource)    { micSource.disconnect();    micSource    = null }
      if (window._micStream) {
        window._micStream.getTracks().forEach(t => t.stop())
        window._micStream = null
      }
      // Phase 37: teardown VU meter
      if (window._micVuStop)    { window._micVuStop(); window._micVuStop = null }
      if (window._micVuRafId)   { cancelAnimationFrame(window._micVuRafId); window._micVuRafId = null }
      if (window._micVuSink)    { window._micVuSink.disconnect();    window._micVuSink    = null }
      if (window._micVuAnalyser){ window._micVuAnalyser.disconnect(); window._micVuAnalyser = null }
      const vuWrap  = document.getElementById('micVuWrap')
      const vuLevel = document.getElementById('micVuLevel')
      if (vuWrap)  vuWrap.style.display = 'none'
      if (vuLevel) vuLevel.style.height  = '0%'
    }

    micMuteBtn.addEventListener('click', () => {
      micMuted = !micMuted
      micMuteBtn.querySelector('.ctrl-icon').textContent = micMuted ? 'ğŸ”‡' : 'ğŸ™ï¸'
      micMuteBtn.classList.toggle('active', micMuted)
      // Mute: disconnect processor so no audio is sent to WS
      if (micMuted) {
        if (micSource && micProcessor) micSource.disconnect(micProcessor)
      } else {
        if (micSource && micProcessor) micSource.connect(micProcessor)
      }
    })

    // â”€â”€ Annotation Mode (Phase 29 â€” networked) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let annotating = false
    let annotDrawing = false
    let annotPoints = []
    let annotClearTimer = null
    const annotateBtn = document.getElementById('annotateBtn')
    const annotationCanvas = document.getElementById('annotationCanvas')
    const annotCtx = annotationCanvas.getContext('2d')

    annotateBtn.addEventListener('click', () => {
      annotating = !annotating
      annotateBtn.classList.toggle('active', annotating)
      annotationCanvas.style.pointerEvents = annotating ? 'auto' : 'none'
      annotationCanvas.style.cursor = annotating ? 'crosshair' : 'default'
      const screenCanvas = document.getElementById('screen')
      screenCanvas.style.pointerEvents = annotating ? 'none' : 'all'
      // Phase 70: mutual exclusion â€” annotation turns off laser
      if (annotating && typeof laserActive !== 'undefined' && laserActive) {
        document.getElementById('laserBtn').click()
      }
    })

    document.getElementById('clearAnnotationsBtn').addEventListener('click', () => {
      clearAnnotationsAll()
    })

    // â”€â”€ Phase 70: Live Laser Pointer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let laserActive = false
    let laserLastSendMs = 0
    const LASER_THROTTLE_MS = 33  // ~30fps

    const laserBtn = document.getElementById('laserBtn')

    laserBtn.addEventListener('click', () => {
      laserActive = !laserActive
      laserBtn.classList.toggle('laser-active', laserActive)
      laserBtn.title = laserActive
        ? 'ğŸ”´ Laser ON â€” move cursor to guide in real time. Click to turn off. (L)'
        : 'ğŸ”´ Laser pointer â€” move cursor to guide in real time (L)'

      if (laserActive) {
        // Laser takes priority â€” disable annotation if active
        if (annotating) {
          annotateBtn.click()
        }
        if (activeWs && activeWs.readyState === WebSocket.OPEN) {
          activeWs.send(JSON.stringify({ type: 'pointer_move_start' }) + '\n')
        }
      } else {
        if (activeWs && activeWs.readyState === WebSocket.OPEN) {
          activeWs.send(JSON.stringify({ type: 'pointer_move_end' }) + '\n')
        }
      }
    })

    // Laser mousemove on screenCanvas (throttled 30fps)
    ;(function setupLaserListeners() {
      const sc = document.getElementById('screen')

      sc.addEventListener('mousemove', (e) => {
        if (!laserActive || !activeWs || activeWs.readyState !== WebSocket.OPEN) return
        const now = Date.now()
        if (now - laserLastSendMs < LASER_THROTTLE_MS) return
        laserLastSendMs = now
        const rect = sc.getBoundingClientRect()
        const x = (e.clientX - rect.left) / rect.width
        const y = (e.clientY - rect.top) / rect.height
        if (x < 0 || x > 1 || y < 0 || y > 1) return
        activeWs.send(JSON.stringify({ type: 'pointer_move', x: +x.toFixed(4), y: +y.toFixed(4) }) + '\n')
      })

      sc.addEventListener('touchmove', (e) => {
        if (!laserActive || !activeWs || activeWs.readyState !== WebSocket.OPEN) return
        const now = Date.now()
        if (now - laserLastSendMs < LASER_THROTTLE_MS) return
        laserLastSendMs = now
        const touch = e.touches[0]
        const rect = sc.getBoundingClientRect()
        const x = (touch.clientX - rect.left) / rect.width
        const y = (touch.clientY - rect.top) / rect.height
        if (x < 0 || x > 1 || y < 0 || y > 1) return
        activeWs.send(JSON.stringify({ type: 'pointer_move', x: +x.toFixed(4), y: +y.toFixed(4) }) + '\n')
      }, { passive: true })
    })()

    function resetLaserState() {
      laserActive = false
      laserBtn.classList.remove('laser-active')
      laserBtn.title = 'ğŸ”´ Laser pointer â€” move cursor to guide in real time (L)'
    }

    function resizeAnnotationCanvas() {
      const wrap = document.getElementById('screenWrap')
      annotationCanvas.width  = wrap.clientWidth
      annotationCanvas.height = wrap.clientHeight
    }
    window.addEventListener('resize', resizeAnnotationCanvas)

    // Sync annotation canvas size to match screen canvas (called on each frame resize)
    function syncAnnotCanvasSize() {
      const screenCanvas = document.getElementById('screen')
      if (annotationCanvas.width !== screenCanvas.width || annotationCanvas.height !== screenCanvas.height) {
        annotationCanvas.width  = screenCanvas.width
        annotationCanvas.height = screenCanvas.height
      }
    }

    function scheduleAnnotClear() {
      if (annotClearTimer) clearTimeout(annotClearTimer)
      annotClearTimer = setTimeout(() => clearAnnotationsAll(), 8000)
    }

    function clearAnnotationsLocal() {
      annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height)
      if (annotClearTimer) { clearTimeout(annotClearTimer); annotClearTimer = null }
    }

    function clearAnnotationsAll() {
      clearAnnotationsLocal()
      if (activeWs && activeWs.readyState === WebSocket.OPEN) {
        activeWs.send(JSON.stringify({ type: 'clear_annotations' }) + '\n')
      }
    }

    function sendAnnotStroke(points) {
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) return
      const normalized = points.map(p => ({
        x: parseFloat((p.x / annotationCanvas.width).toFixed(4)),
        y: parseFloat((p.y / annotationCanvas.height).toFixed(4))
      }))
      activeWs.send(JSON.stringify({ type: 'annotation', points: normalized, color: '#ff3333', width: 4 }) + '\n')
    }

    function getAnnotPoint(e) {
      const rect = annotationCanvas.getBoundingClientRect()
      const scaleX = annotationCanvas.width / rect.width
      const scaleY = annotationCanvas.height / rect.height
      const src = e.touches ? e.touches[0] : e
      return { x: (src.clientX - rect.left) * scaleX, y: (src.clientY - rect.top) * scaleY }
    }

    function drawSegment(from, to) {
      annotCtx.save()
      annotCtx.strokeStyle = '#ff3333'; annotCtx.lineWidth = 4
      annotCtx.lineCap = 'round'; annotCtx.lineJoin = 'round'
      annotCtx.beginPath(); annotCtx.moveTo(from.x, from.y); annotCtx.lineTo(to.x, to.y)
      annotCtx.stroke(); annotCtx.restore()
    }

    annotationCanvas.addEventListener('mousedown', (e) => {
      if (!annotating) return
      annotDrawing = true; annotPoints = [getAnnotPoint(e)]; e.preventDefault()
    })
    annotationCanvas.addEventListener('mousemove', (e) => {
      if (!annotating || !annotDrawing) return
      const pt = getAnnotPoint(e)
      if (annotPoints.length) drawSegment(annotPoints[annotPoints.length - 1], pt)
      annotPoints.push(pt); e.preventDefault()
    })
    annotationCanvas.addEventListener('mouseup', (e) => {
      if (!annotating || !annotDrawing) return
      annotDrawing = false
      if (annotPoints.length >= 2) { sendAnnotStroke(annotPoints); scheduleAnnotClear() }
      annotPoints = []
    })
    annotationCanvas.addEventListener('touchstart', (e) => {
      if (!annotating) return
      annotDrawing = true; annotPoints = [getAnnotPoint(e)]; e.preventDefault()
    }, { passive: false })
    annotationCanvas.addEventListener('touchmove', (e) => {
      if (!annotating || !annotDrawing) return
      const pt = getAnnotPoint(e)
      if (annotPoints.length) drawSegment(annotPoints[annotPoints.length - 1], pt)
      annotPoints.push(pt); e.preventDefault()
    }, { passive: false })
    annotationCanvas.addEventListener('touchend', (e) => {
      if (!annotating || !annotDrawing) return
      annotDrawing = false
      if (annotPoints.length >= 2) { sendAnnotStroke(annotPoints); scheduleAnnotClear() }
      annotPoints = []
    })

    // â”€â”€ Session view toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function showSessionView() {
      connectUI.style.display = 'none'
      sessionView.classList.add('active')
      document.getElementById('privacyNote').style.display = 'block'
      document.getElementById('streamMode').style.display = 'block'
      fpsEl.style.display = 'inline-block'
      // Phase 11: crosshair cursor + pointer hint (Phase 16: respect zoom state)
      if (zoomLevel <= 1.01) document.getElementById('screen').style.cursor = 'crosshair'
      document.getElementById('pointerHint').style.display = 'block'
      // Phase 18: privacy badge
      document.getElementById('privacyBadge').style.display = 'inline'
      // Phase 24: hide scan button during active session
      document.getElementById('scanQrBtn').style.display = 'none'
      // Phase 27: session timer
      startSessionTimer()
      document.getElementById('sessionTimer').style.display = 'inline-block'
      // Resize annotation canvas
      resizeAnnotationCanvas()
      // Phase 33: show webcam PiP button during session (if getUserMedia available)
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        document.getElementById('helperCamBtn').style.display = 'inline-flex'
      }
      // Phase 42: show screen share button during session (getDisplayMedia available)
      if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
        document.getElementById('helperScreenBtn').style.display = 'inline-flex'
      }
      // Phase 51: show Refresh + Quality selector during session
      document.getElementById('refreshBtn').style.display = 'inline-flex'
      document.getElementById('qualitySelector').style.display = 'inline-flex'
      manualQualityOverride = false
      // Reset quality buttons to MED (default)
      document.querySelectorAll('.quality-btn').forEach(b => b.classList.toggle('active', b.dataset.tier === 'MED'))
      // Phase 53: show stream health pill + start auto-recovery watchdog
      const healthPill = document.getElementById('streamHealthPill')
      if (healthPill) healthPill.style.display = 'inline-flex'
      lastFrameReceivedMs = 0
      autoRecoveryActive  = false
      autoRecoveryCount   = 0
      frameSizeHistory.length = 0
      startAutoRecoveryWatchdog()
      // Phase 54: reset battery/network badges (populated when elder sends first status)
      const batteryBadge = document.getElementById('batteryBadge')
      const networkBadge = document.getElementById('networkBadge')
      if (batteryBadge) { batteryBadge.style.display = 'none'; document.getElementById('batteryLabel').textContent = 'â€”' }
      if (networkBadge) { networkBadge.style.display = 'none'; document.getElementById('networkLabel').textContent = 'â€”' }
      // Phase 54: show audio controls + start mic decay timer
      document.getElementById('elderMicGroup').style.display = 'inline-flex'
      document.getElementById('audioVolumeGroup').style.display = 'inline-flex'
      volumeSlider.value = 100
      volumeLabel.textContent = '100%'
      startElderMicDecay()
      // Phase 55: show Record button if MediaRecorder available (Chrome 120+)
      if (typeof MediaRecorder !== 'undefined') {
        document.getElementById('recBtn').style.display = 'inline-flex'
      }
      // Phase 59: show notification badge + fire session-start notification
      if (window._showNotifBadge) window._showNotifBadge()
      if (window.sendDesktopNotif) window.sendDesktopNotif('FamDesk â€” Session Started ğŸ–¥ï¸', 'The session is live. Their screen is loadingâ€¦', 'force')
      // Phase 64: show Send Image button during session
      document.getElementById('sendImageBtn').style.display = 'inline-flex'
      // Phase 70: show Laser Pointer button during session
      document.getElementById('laserBtn').style.display = 'inline-flex'
      // Phase 66: show Shortcuts Help button during session
      document.getElementById('shortcutsHelpBtn').style.display = 'inline-flex'
      // Phase 65 / Phase 71: show Settings Launcher in drawer during session
      const slg = document.getElementById('settingsLauncherGroup')
      if (slg) { slg.style.display = 'block' }
    }

    function hideSessionView() {
      connectUI.style.display = 'flex'
      sessionView.classList.remove('active')
      document.getElementById('privacyNote').style.display = 'none'
      // Phase 18: privacy badge
      document.getElementById('privacyBadge').style.display = 'none'
      // Phase 53: hide health pill + stop watchdog
      const healthPill = document.getElementById('streamHealthPill')
      if (healthPill) healthPill.style.display = 'none'
      stopAutoRecoveryWatchdog()
      // Phase 54: hide battery/network badges
      const bb = document.getElementById('batteryBadge')
      const nb = document.getElementById('networkBadge')
      if (bb) bb.style.display = 'none'
      if (nb) nb.style.display = 'none'
    }

    // â”€â”€ Chat toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const chatPanel = document.getElementById('chatPanel')
    const chatToggleBtn = document.getElementById('chatToggleBtn')
    chatToggleBtn.addEventListener('click', () => {
      chatPanel.classList.toggle('collapsed')
      chatToggleBtn.classList.toggle('active', !chatPanel.classList.contains('collapsed'))
    })

    // â”€â”€ Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let activeWs = null

    function esc(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    }
    function fmtTime(d) {
      d = d || new Date()
      return d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0')
    }
    // Phase 68: track sent message receipt elements â€” ts â†’ DOM span
    const sentMessages = {}

    function appendChat(text, who, label, ts) {
      const el = document.createElement('div')
      // Map 'peer' â†’ 'them' for new bubble classes; keep 'me' and 'system'
      const bubbleClass = who === 'peer' ? 'them' : who
      el.className = 'chat-bubble ' + bubbleClass
      if (who === 'system') {
        el.textContent = text
      } else if (who === 'me' && ts) {
        // Phase 68: helper-sent bubble â€” start with Â· (sending), advance to âœ“ after render
        el.dataset.ts = ts
        const labelStr = label ? esc(label) + ' Â· ' : ''
        el.innerHTML = `<div>${esc(text)}<span class="msg-receipt" data-receipt-ts="${ts}" title="Sending">Â·</span></div><div class="meta">${labelStr}${fmtTime()}</div>`
        // After render: advance to âœ“ (delivered) and register for read_receipt tracking
        setTimeout(() => {
          const span = el.querySelector(`[data-receipt-ts="${ts}"]`)
          if (span) {
            span.textContent = 'âœ“'
            span.title = 'Delivered'
            sentMessages[ts] = span
          }
        }, 0)
      } else {
        const labelStr = label ? esc(label) + ' Â· ' : ''
        el.innerHTML = `<div>${esc(text)}</div><div class="meta">${labelStr}${fmtTime()}</div>`
      }
      chatMessages.appendChild(el)
      chatMessages.scrollTop = chatMessages.scrollHeight
      // Phase 59: desktop notification for incoming peer message (when backgrounded)
      if ((who === 'peer' || who === 'them') && window.sendDesktopNotif) {
        const preview = text.length > 80 ? text.slice(0, 77) + 'â€¦' : text
        window.sendDesktopNotif('FamDesk ğŸ’¬ Message from User', preview, 'chat')
      }
    }

    // Phase 68: typing indicator state
    let typingTimeout = null

    function handleTypingEvent(active) {
      const el = document.getElementById('typingIndicator')
      if (!el) return
      if (active) {
        el.style.display = 'flex'
        clearTimeout(typingTimeout)
        typingTimeout = setTimeout(() => { el.style.display = 'none' }, 4000)
      } else {
        clearTimeout(typingTimeout)
        el.style.display = 'none'
      }
    }

    function sendChat() {
      const text = chatInput.value.trim()
      if (!text || !activeWs || activeWs.readyState !== WebSocket.OPEN) return
      const ts = Date.now()
      activeWs.send(JSON.stringify({ type: 'chat', text, from: 'helper', ts }) + '\n')
      appendChat(text, 'me', 'You', ts)
      chatInput.value = ''
    }

    document.getElementById('sendChatBtn').addEventListener('click', sendChat)
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat() }
    })

    // â”€â”€ Fullscreen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const fullscreenBtn = document.getElementById('fullscreenBtn')
    fullscreenBtn.addEventListener('click', () => {
      const wrap = document.getElementById('screenWrap')
      if (!document.fullscreenElement) {
        wrap.requestFullscreen().catch(() => {})
      } else {
        document.exitFullscreen()
      }
    })
    document.addEventListener('fullscreenchange', () => {
      fullscreenBtn.querySelector('.ctrl-icon').textContent = document.fullscreenElement ? 'âœ•' : 'â›¶'
    })

    // â”€â”€ Phase 78: Snap button â€” request high-res still from elder's camera â”€â”€â”€â”€â”€â”€
    ;(function setupSnapBtn() {
      const snapBtnEl = document.getElementById('snapBtn')
      if (!snapBtnEl) return
      snapBtnEl.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return
        ws.send(JSON.stringify({ type: 'camera_snapshot_request' }))
        appendChat('ğŸ“¸ Snapshot requested â€” waiting for elderâ€¦', 'system')
        snapBtnEl.disabled = true
        // Re-enable after 6s (fallback if no snapshot arrives)
        setTimeout(() => { snapBtnEl.disabled = false }, 6000)
      })
    })()

    // â”€â”€ Phase 71: â‹® More button â€” overflow drawer toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ;(function setupMoreDrawer() {
      const moreBtn = document.getElementById('moreBtn')
      const drawer  = document.getElementById('toolbarDrawer')

      moreBtn.addEventListener('click', (e) => {
        e.stopPropagation()
        const open = drawer.classList.toggle('open')
        moreBtn.classList.toggle('active', open)
      })

      // Close on outside click
      document.addEventListener('click', (e) => {
        if (!drawer.contains(e.target) && e.target !== moreBtn) {
          drawer.classList.remove('open')
          moreBtn.classList.remove('active')
        }
      })

      // Close on drawer item click (except quality buttons â€” those are stateful)
      drawer.addEventListener('click', (e) => {
        const item = e.target.closest('.drawer-item')
        if (item && !item.classList.contains('quality-btn')) {
          // Slight delay so the button action fires first
          setTimeout(() => {
            drawer.classList.remove('open')
            moreBtn.classList.remove('active')
          }, 80)
        }
      })
    })()
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // â”€â”€ Phase 27: Session timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let sessionTimerInterval = null
    let sessionStartMs = null

    function startSessionTimer() {
      sessionStartMs = Date.now()
      const el = document.getElementById('sessionTimer')
      sessionTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - sessionStartMs) / 1000)
        const mm = String(Math.floor(elapsed / 60)).padStart(2, '0')
        const ss = String(elapsed % 60).padStart(2, '0')
        el.textContent = `â± ${mm}:${ss}`
      }, 1000)
    }

    function stopSessionTimer() {
      if (sessionTimerInterval) { clearInterval(sessionTimerInterval); sessionTimerInterval = null }
      sessionStartMs = null
      document.getElementById('sessionTimer').textContent = 'â± 00:00'
    }

    // â”€â”€ Phase 27: Screenshot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('screenshotBtn').addEventListener('click', () => {
      const screenCanvas = document.getElementById('screen')
      if (!screenCanvas || screenCanvas.width === 0) return
      screenCanvas.toBlob(blob => {
        if (!blob) return
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        const now = new Date()
        const ts = `${String(now.getHours()).padStart(2,'0')}-${String(now.getMinutes()).padStart(2,'0')}-${String(now.getSeconds()).padStart(2,'0')}`
        a.download = `famdesk-screenshot-${ts}.png`
        a.href = url
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
        appendChat(`ğŸ“¸ Screenshot saved as famdesk-screenshot-${ts}.png`, 'system')
      }, 'image/png')
    })

    // â”€â”€ Phase 66: Send screen snap to them (Shift+S) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function sendSnapToElder() {
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) {
        appendChat('âš ï¸ Not connected â€” snap not sent.', 'system')
        return
      }
      const screenCanvas = document.getElementById('screen')
      if (!screenCanvas || screenCanvas.width === 0) {
        appendChat('âš ï¸ No screen to snap.', 'system')
        return
      }
      // Resize to same limits as Phase 64 sendImageToElder (max 800Ã—1200)
      const MAX_W = 800, MAX_H = 1200
      let w = screenCanvas.width, h = screenCanvas.height
      if (w > MAX_W || h > MAX_H) {
        const scale = Math.min(MAX_W / w, MAX_H / h)
        w = Math.round(w * scale)
        h = Math.round(h * scale)
      }
      const cvs = document.createElement('canvas')
      cvs.width = w; cvs.height = h
      cvs.getContext('2d').drawImage(screenCanvas, 0, 0, w, h)
      const base64 = cvs.toDataURL('image/jpeg', 0.80).split(',')[1]
      sendImageToElder(base64, '')  // send with no caption (instant snap, no prompt)
    }

    // â”€â”€ Phase 66: Keyboard shortcuts guide modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function showShortcutsModal() {
      document.getElementById('shortcutsModal').style.display = 'flex'
    }
    document.getElementById('shortcutsCloseBtn').addEventListener('click', () => {
      document.getElementById('shortcutsModal').style.display = 'none'
    })
    document.getElementById('shortcutsModal').addEventListener('click', (e) => {
      // Click outside the card to close
      if (e.target === document.getElementById('shortcutsModal')) {
        document.getElementById('shortcutsModal').style.display = 'none'
      }
    })
    document.getElementById('shortcutsHelpBtn').addEventListener('click', showShortcutsModal)

    // â”€â”€ Phase 27: Paste text panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('pasteBtn').addEventListener('click', () => {
      const panel = document.getElementById('pastePanel')
      const shown = panel.style.display === 'flex'
      document.getElementById('quickMsgPanel').style.display = 'none'  // Phase 60: close sibling panel
      panel.style.display = shown ? 'none' : 'flex'
      if (!shown) document.getElementById('pasteTextInput').focus()
    })

    function sendPasteText() {
      const text = document.getElementById('pasteTextInput').value.trim()
      if (!text) return
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) {
        appendChat('âš ï¸ Not connected â€” cannot send paste text.', 'system')
        return
      }
      activeWs.send(JSON.stringify({ type: 'paste_text', text }) + '\n')
      appendChat(`ğŸ“‹ Text sent to user's clipboard: "${text.length > 40 ? text.slice(0, 40) + 'â€¦' : text}"`, 'system')
      document.getElementById('pasteTextInput').value = ''
      document.getElementById('pastePanel').style.display = 'none'
    }

    document.getElementById('pasteSendBtn').addEventListener('click', sendPasteText)
    document.getElementById('pasteCancelBtn').addEventListener('click', () => {
      document.getElementById('pastePanel').style.display = 'none'
    })
    document.getElementById('pasteTextInput').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendPasteText() }
      if (e.key === 'Escape') { document.getElementById('pastePanel').style.display = 'none' }
    })

    // â”€â”€ Phase 60: Quick Message panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function sendQuickMsg(text) {
      text = (text || '').trim()
      if (!text) return
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) {
        appendChat('âš ï¸ Not connected â€” cannot send message.', 'system')
        return
      }
      activeWs.send(JSON.stringify({ type: 'helper_message', text }) + '\n')
      appendChat(`ğŸ’¬ Message sent to user's screen: "${text.length > 50 ? text.slice(0, 50) + 'â€¦' : text}"`, 'system')
      document.getElementById('quickMsgInput').value = ''
      appendDebugLog('helper', `Sent quick message: "${text}"`)
    }

    document.getElementById('quickMsgBtn').addEventListener('click', () => {
      const panel = document.getElementById('quickMsgPanel')
      const pastPanel = document.getElementById('pastePanel')
      pastPanel.style.display = 'none'  // close paste panel if open
      const shown = panel.style.display === 'flex'
      panel.style.display = shown ? 'none' : 'flex'
      if (!shown) document.getElementById('quickMsgInput').focus()
    })

    document.getElementById('quickMsgSendBtn').addEventListener('click', () => {
      sendQuickMsg(document.getElementById('quickMsgInput').value)
    })

    document.getElementById('quickMsgCancelBtn').addEventListener('click', () => {
      document.getElementById('quickMsgPanel').style.display = 'none'
    })

    document.getElementById('quickMsgInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); sendQuickMsg(document.getElementById('quickMsgInput').value) }
      if (e.key === 'Escape') { document.getElementById('quickMsgPanel').style.display = 'none' }
    })

    // Wire chip clicks
    document.querySelectorAll('.msg-chip').forEach(chip => {
      chip.addEventListener('click', () => sendQuickMsg(chip.dataset.msg))
    })

    // â”€â”€ Phase 64: Send Image to elder's screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function sendImageToElder(base64, caption) {
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) {
        appendChat('âš ï¸ Not connected â€” image not sent.', 'system')
        return
      }
      if (base64.length > 800000) {
        alert('Image is too large. Please send a smaller screenshot.')
        return
      }
      activeWs.send(JSON.stringify({ type: 'helper_image', data: base64, caption: caption.trim(), mimeType: 'image/jpeg' }) + '\n')
      appendChat(`ğŸ“· Image sent${caption.trim() ? `: "${caption.trim()}"` : ''}`, 'system')
      appendStatus('ğŸ“· Image sent to user')
      appendDebugLog('helper', `Sent image (${base64.length} base64 chars), caption="${caption}"`)
    }

    function compressAndSendImage(dataUrl) {
      const img = new window.Image()
      img.onload = () => {
        const MAX_W = 800, MAX_H = 1200
        let w = img.width, h = img.height
        if (w > MAX_W || h > MAX_H) {
          const scale = Math.min(MAX_W / w, MAX_H / h)
          w = Math.round(w * scale)
          h = Math.round(h * scale)
        }
        const cvs = document.createElement('canvas')
        cvs.width = w; cvs.height = h
        cvs.getContext('2d').drawImage(img, 0, 0, w, h)
        const jpegData = cvs.toDataURL('image/jpeg', 0.80)
        const base64 = jpegData.split(',')[1]
        const caption = prompt('Caption (optional):', '') || ''
        sendImageToElder(base64, caption)
      }
      img.src = dataUrl
    }

    document.getElementById('sendImageBtn').addEventListener('click', () => {
      document.getElementById('imageFileInput').click()
    })

    document.getElementById('imageFileInput').addEventListener('change', (e) => {
      const file = e.target.files[0]
      if (!file) return
      e.target.value = ''  // reset so same file can be re-sent
      const reader = new FileReader()
      reader.onload = (ev) => compressAndSendImage(ev.target.result)
      reader.readAsDataURL(file)
    })

    // â”€â”€ Phase 65 / Phase 71: Settings items (now inline in overflow drawer) â”€â”€
    ;(function setupSettingsLauncher() {
      document.querySelectorAll('.settings-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation()
          const action = item.dataset.action
          // Close drawer after selecting an action
          document.getElementById('toolbarDrawer').classList.remove('open')
          if (!activeWs || activeWs.readyState !== WebSocket.OPEN) return
          activeWs.send(JSON.stringify({ type: 'open_setting', action }) + '\n')
          appendStatus(`âš™ï¸ Opening ${item.textContent.trim()} on user's deviceâ€¦`)
          appendDebugLog('helper', `Sent open_setting: ${action}`)
        })
      })
    })()

    // â”€â”€ Phase 27: Keyboard shortcuts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.addEventListener('keydown', (e) => {
      if (!sessionViewShown) return
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return
      switch (e.key) {
        case 'm': case 'M':
          if (!e.shiftKey) muteBtn.click()
          else micMuteBtn.click()
          break
        case 'f': case 'F':
          fullscreenBtn.click()
          break
        case 's': case 'S':
          if (e.shiftKey) sendSnapToElder()       // Phase 66: Shift+S â†’ send snap to elder
          else document.getElementById('screenshotBtn').click()
          break
        case 'p': case 'P':
          document.getElementById('pasteBtn').click()
          break
        case 'a': case 'A':
          document.getElementById('annotateBtn').click()
          break
        case 'i': case 'I':
          document.getElementById('sendImageBtn').click()  // Phase 64: send reference image
          break
        case 'l': case 'L':
          if (document.getElementById('laserBtn').style.display !== 'none') {
            document.getElementById('laserBtn').click()  // Phase 70: laser pointer toggle
          }
          break
        case 'd': case 'D':
          // Phase 81: toggle stream debug stats overlay
          jitterStatsVisible = !jitterStatsVisible
          const statsEl = document.getElementById('streamStats')
          if (statsEl) {
            statsEl.style.display = jitterStatsVisible ? 'block' : 'none'
            if (jitterStatsVisible) updateJitterStats()
          }
          break
        case '?':
          showShortcutsModal()  // Phase 66: keyboard shortcuts guide
          break
        case 'Escape':
          document.getElementById('pastePanel').style.display = 'none'
          document.getElementById('quickMsgPanel').style.display = 'none'  // Phase 60
          document.getElementById('shortcutsModal').style.display = 'none'  // Phase 66
          document.getElementById('toolbarDrawer').classList.remove('open') // Phase 71
          clearAnnotationsLocal()
          // Phase 70: Escape turns off laser pointer
          if (laserActive) document.getElementById('laserBtn').click()
          break
      }
    })

    // â”€â”€ Remote Pointer (Phase 11) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function sendPointer(e) {
      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) return
      const screenCanvas = document.getElementById('screen')
      const rect = screenCanvas.getBoundingClientRect()
      // Handle both mouse click and touch events
      const clientX = e.touches ? e.touches[0].clientX : e.clientX
      const clientY = e.touches ? e.touches[0].clientY : e.clientY
      const x = (clientX - rect.left) / rect.width
      const y = (clientY - rect.top) / rect.height
      if (x < 0 || x > 1 || y < 0 || y > 1) return

      activeWs.send(JSON.stringify({ type: 'pointer', x: +x.toFixed(4), y: +y.toFixed(4) }) + '\n')

      // Draw a brief local ripple so helper knows the tap registered
      showLocalPointer(clientX - rect.left, clientY - rect.top)
    }

    function showLocalPointer(px, py) {
      // Draw a brief white ring on the canvas â€” will be overwritten by next frame
      ctx.save()
      ctx.beginPath()
      ctx.arc(px, py, 20, 0, Math.PI * 2)
      ctx.strokeStyle = 'rgba(255,255,255,0.9)'
      ctx.lineWidth = 3
      ctx.stroke()
      ctx.beginPath()
      ctx.arc(px, py, 8, 0, Math.PI * 2)
      ctx.fillStyle = 'rgba(255,68,68,0.8)'
      ctx.fill()
      ctx.restore()
    }

    const screenCanvas = document.getElementById('screen')
    // Phase 11: pointer â€” skip if the click was actually a pan drag (Phase 16)
    screenCanvas.addEventListener('click', (e) => {
      if (skipNextClick) { skipNextClick = false; return }
      sendPointer(e)
    })
    screenCanvas.addEventListener('touchstart', (e) => {
      // 1-finger tap â†’ pointer; 2-finger â†’ pinch zoom (handled in Phase 16 block)
      if (e.touches.length === 1) {
        e.preventDefault()
        sendPointer(e)
      }
    }, { passive: false })

    // â”€â”€ FPS health badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let frameCount  = 0
    let lastFpsTs   = performance.now()
    let lastFrameAt = 0
    let fpsPauseTimer = null

    // â”€â”€ Phase 34: Session stats tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let totalFrames      = 0    // cumulative frames received this session
    let rttSamples       = []   // RTT values (ms) for average latency display
    let sessionStreamMode = null // last stream_info mode ('screen'|'camera')

    // â”€â”€ Phase 53: Auto frame recovery + stream health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastFrameReceivedMs  = 0
    let autoRecoveryActive   = false
    let autoRecoveryTimer    = null
    let autoRecoveryCount    = 0
    const frameSizeHistory   = []   // [{ts:ms, bytes:n}] â€” rolling 3s bandwidth window

    function onFrameReceived(frameBytes) {
      const now = Date.now()
      lastFrameReceivedMs = now
      frameSizeHistory.push({ ts: now, bytes: frameBytes || 0 })
      // Keep only last 3s of history
      const cutoff = now - 3000
      while (frameSizeHistory.length > 0 && frameSizeHistory[0].ts < cutoff) {
        frameSizeHistory.shift()
      }
      if (autoRecoveryActive) {
        autoRecoveryActive = false
        updateStreamHealthPill()
        appendStatus('â†» Stream recovered', 'info')
      }
    }

    function estimateBandwidth() {
      if (frameSizeHistory.length < 2) return 0
      const totalBytes = frameSizeHistory.reduce((s, f) => s + f.bytes, 0)
      const windowMs   = Date.now() - frameSizeHistory[0].ts
      if (windowMs < 100) return 0
      return (totalBytes / windowMs) * 1000  // bytes/sec
    }

    function updateStreamHealthPill() {
      const pill = document.getElementById('streamHealthPill')
      if (!pill || pill.style.display === 'none') return
      const staleness = lastFrameReceivedMs ? Date.now() - lastFrameReceivedMs : 0
      const bwBps     = estimateBandwidth()

      const ageLabel = document.getElementById('frameAgeLabel')
      if (ageLabel) {
        ageLabel.textContent = staleness < 1000 ? staleness + 'ms' : (staleness / 1000).toFixed(1) + 's'
      }

      const icon = document.getElementById('healthIcon')
      if (icon) {
        if (autoRecoveryActive)  icon.textContent = 'â†»'
        else if (staleness < 500) icon.textContent = 'ğŸŸ¢'
        else if (staleness < 1500) icon.textContent = 'ğŸŸ¡'
        else                      icon.textContent = 'ğŸ”´'
      }

      const bwEl = document.getElementById('bandwidthLabel')
      if (bwEl) {
        if (bwBps === 0) {
          bwEl.textContent = 'â€”'
        } else if (bwBps >= 1024 * 1024) {
          bwEl.textContent = (bwBps / (1024 * 1024)).toFixed(1) + ' MB/s'
        } else {
          bwEl.textContent = Math.round(bwBps / 1024) + ' KB/s'
        }
      }
    }

    // Phase 54: Battery + Network status badge updaters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function updateBatteryBadge(level, charging) {
      const badge = document.getElementById('batteryBadge')
      const icon  = document.getElementById('batteryIcon')
      const label = document.getElementById('batteryLabel')
      if (!badge || !icon || !label) return
      if (charging) {
        icon.textContent = 'âš¡'
        badge.title = 'Battery: ' + level + '% â€” charging'
      } else if (level >= 50) {
        icon.textContent = 'ğŸ”‹'
        badge.title = 'Battery: ' + level + '%'
      } else if (level >= 20) {
        icon.textContent = 'ğŸª«'
        badge.title = 'Battery: ' + level + '% â€” getting low'
      } else {
        icon.textContent = 'ğŸ”´'
        badge.title = 'Battery: ' + level + '% â€” CRITICAL'
      }
      label.textContent = level + '%'
      badge.style.display = 'inline-flex'
    }

    function updateNetworkBadge(netType, level, generation) {
      const badge = document.getElementById('networkBadge')
      const icon  = document.getElementById('networkIcon')
      const label = document.getElementById('networkLabel')
      if (!badge || !icon || !label) return
      if (netType === 'wifi') {
        icon.textContent = 'ğŸ“¶'
        const bars = ['â–', 'â–â–ƒ', 'â–â–ƒâ–…', 'â–â–ƒâ–…â–‡'][Math.min(level || 0, 3)]
        label.textContent = 'WiFi ' + bars
        badge.title = 'Network: WiFi (signal ' + (level || 0) + '/3)'
      } else if (netType === 'cellular') {
        icon.textContent = 'ğŸ“±'
        label.textContent = generation || 'LTE'
        badge.title = 'Network: Cellular â€” ' + (generation || 'LTE')
      } else {
        icon.textContent = 'ğŸŒ'
        label.textContent = netType || '?'
        badge.title = 'Network: ' + (netType || 'unknown')
      }
      badge.style.display = 'inline-flex'
    }
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Phase 79: Update #elderMicPanel from Android-side RMS IPC message
    function updateElderMicPanel(level) {
      const panel  = document.getElementById('elderMicPanel')
      const bar    = document.getElementById('elderMicBar')
      const status = document.getElementById('elderMicStatus')
      if (!panel || !bar || !status) return
      panel.style.display = 'inline-flex'
      const pct = Math.round(level * 100)
      bar.style.width = pct + '%'
      bar.classList.remove('m79-warn', 'm79-clip')
      if (level < 0.01) {
        status.textContent = 'ğŸ”‡'
      } else if (level < 0.75) {
        status.textContent = 'ğŸŸ¢'
      } else if (level < 0.95) {
        bar.classList.add('m79-warn')
        status.textContent = 'ğŸŸ¡'
      } else {
        bar.classList.add('m79-clip')
        status.textContent = 'ğŸ”´'
      }
    }

    // Phase 79: Reset elder mic panel on session end
    function resetElderMicLevel() {
      const panel = document.getElementById('elderMicPanel')
      if (panel) panel.style.display = 'none'
      const bar = document.getElementById('elderMicBar')
      if (bar) { bar.style.width = '0%'; bar.classList.remove('m79-warn', 'm79-clip') }
      const status = document.getElementById('elderMicStatus')
      if (status) status.textContent = 'ğŸ”‡'
    }

    // Phase 80: FLAG_SECURE privacy overlay â€” show/hide helpers
    function showPrivacyOverlay() {
      const overlay = document.getElementById('privacyOverlay')
      if (overlay) overlay.style.display = 'flex'
    }
    function hidePrivacyOverlay() {
      const overlay = document.getElementById('privacyOverlay')
      if (overlay) overlay.style.display = 'none'
    }

    function startAutoRecoveryWatchdog() {
      stopAutoRecoveryWatchdog()
      autoRecoveryTimer = setInterval(() => {
        if (!sessionViewShown || lastFrameReceivedMs === 0) return

        // Only trigger for screen-share mode â€” camera frames arrive at a different rate
        if (sessionStreamMode === 'camera') return

        const staleness  = Date.now() - lastFrameReceivedMs
        // Use wider threshold when LOW quality tier is active (lower frame rate expected)
        const currentTier = (() => {
          const active = document.querySelector('.quality-btn.active')
          return active ? active.dataset.tier : 'MED'
        })()
        const threshold = currentTier === 'LOW' ? 3000 : 1500

        if (staleness > threshold && !autoRecoveryActive) {
          autoRecoveryActive = true
          autoRecoveryCount++
          updateStreamHealthPill()

          const sendKeyframe = () => {
            if (activeWs && activeWs.readyState === WebSocket.OPEN) {
              activeWs.send(JSON.stringify({ type: 'request_keyframe' }) + '\n')
            }
          }
          sendKeyframe()

          // Up to 3 retry attempts, 3s apart
          let attempts = 0
          const retryInterval = setInterval(() => {
            attempts++
            if (!autoRecoveryActive || attempts >= 3) {
              clearInterval(retryInterval)
              return
            }
            sendKeyframe()
          }, 3000)
        }

        updateStreamHealthPill()
      }, 500)
    }

    function stopAutoRecoveryWatchdog() {
      if (autoRecoveryTimer) { clearInterval(autoRecoveryTimer); autoRecoveryTimer = null }
    }

    function appendStatus(text, _cls) {
      // lightweight one-liner status append (re-uses chat area for Phase 53 recovery notes)
      appendChat(text, 'system')
    }

    // â”€â”€ Adaptive quality tier (Phase 12) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Sends quality_hint to Android when FPS tier changes.
    // Helper measures FPS â†’ sends hint â†’ Android adjusts JPEG quality.
    // Tier  | FPS condition          | JPEG quality
    // LOW   | <5fps sustained 3s    | 35
    // MED   | 5â€“8fps               | 60 (default)
    // HIGH  | â‰¥9fps sustained 5s   | 72
    let lastQualityTier = 'MED'
    let highFpsCount    = 0   // consecutive 1s buckets â‰¥9fps (need 5 for HIGH)
    let lowFpsCount     = 0   // consecutive 1s buckets <5fps (need 3 for LOW)

    function checkQualityTier(fps) {
      if (fps >= 9)      { highFpsCount++; lowFpsCount = 0 }
      else if (fps < 5)  { lowFpsCount++;  highFpsCount = 0 }
      else               { highFpsCount = 0; lowFpsCount = 0 }  // 5â€“8 resets both

      const tier = highFpsCount >= 5 ? 'HIGH'
                 : lowFpsCount  >= 3 ? 'LOW'
                 : 'MED'

      if (tier !== lastQualityTier) {
        lastQualityTier = tier
        if (activeWs && activeWs.readyState === WebSocket.OPEN) {
          activeWs.send(JSON.stringify({ type: 'quality_hint', tier, fps: Math.round(fps) }) + '\n')
          console.log('[quality] Tier â†’', tier, '@ fps:', fps.toFixed(1))
        }
        syncQualitySelector(tier)   // Phase 51: keep quality buttons in sync with auto-loop
      }
    }

    function resetQualityTier() {
      lastQualityTier = 'MED'
      highFpsCount    = 0
      lowFpsCount     = 0
    }

    // â”€â”€ Phase 51: Refresh Button + Manual Quality Selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Refresh: sends request_keyframe â†’ forces Android H.264 encoder to emit IDR
    // Quality: Low/Med/High manual override of the Phase 12 FPS auto-quality loop
    const QUALITY_MAP = { LOW: 35, MED: 60, HIGH: 72 }
    let manualQualityOverride = false

    // Sync quality buttons to match a tier (skip if user manually overrode)
    function syncQualitySelector(tier) {
      if (manualQualityOverride) return
      document.querySelectorAll('.quality-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.tier === tier)
      })
    }

    // Wire Refresh + Quality buttons â€” called immediately (script at bottom, DOM already parsed)
    function initPhase51Controls() {
      const refreshBtn = document.getElementById('refreshBtn')
      const qualitySelector = document.getElementById('qualitySelector')


      refreshBtn.addEventListener('click', () => {
        if (activeWs && activeWs.readyState === WebSocket.OPEN) {
          activeWs.send(JSON.stringify({ type: 'request_keyframe' }) + '\n')
          refreshBtn.classList.add('active')
          setTimeout(() => refreshBtn.classList.remove('active'), 500)
          console.log('[phase51] Keyframe refresh requested')
        }
      })

      document.querySelectorAll('.quality-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tier = btn.dataset.tier
          document.querySelectorAll('.quality-btn').forEach(b => b.classList.remove('active'))
          btn.classList.add('active')
          manualQualityOverride = true
          if (activeWs && activeWs.readyState === WebSocket.OPEN) {
            activeWs.send(JSON.stringify({ type: 'quality_hint', tier, q: QUALITY_MAP[tier] }) + '\n')
            console.log('[phase51] Manual quality override â†’', tier)
          }
        })
      })
    }

    initPhase51Controls()   // Phase 51: wire up Refresh + Quality buttons

    // â”€â”€ Phase 16: Canvas Zoom + RTT Latency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Zoom: mouse wheel or pinch-to-zoom on the canvas.
    // Pan: drag while zoomed (left mouse). Double-click to reset.
    // Latency: send ping every 5s, measure pong round-trip.
    const screenWrap = document.getElementById('screenWrap')
    const zoomBadgeEl = document.getElementById('zoomBadge')
    const latencyBadgeEl = document.getElementById('latencyBadge')
    const zoomResetBtn = document.getElementById('zoomResetBtn')

    let zoomLevel  = 1.0
    let zoomTx     = 0
    let zoomTy     = 0
    let isPanning  = false
    let panLastX   = 0
    let panLastY   = 0
    let skipNextClick = false  // suppress pointer after a pan drag

    function applyZoom() {
      if (zoomLevel <= 1.005) {
        canvas.style.transform = ''
        canvas.style.transformOrigin = ''
        zoomBadgeEl.style.display = 'none'
        zoomResetBtn.style.display = 'none'
        canvas.style.cursor = sessionViewShown ? 'crosshair' : 'default'
      } else {
        canvas.style.transformOrigin = '0 0'
        canvas.style.transform = `translate(${zoomTx}px, ${zoomTy}px) scale(${zoomLevel})`
        zoomBadgeEl.textContent = `${zoomLevel.toFixed(1)}x`
        zoomBadgeEl.style.display = 'inline-block'
        zoomResetBtn.style.display = 'block'
        canvas.style.cursor = isPanning ? 'grabbing' : 'grab'
      }
    }

    function resetZoom() {
      zoomLevel = 1.0; zoomTx = 0; zoomTy = 0
      applyZoom()
    }

    function clampPan() {
      const ww = screenWrap.clientWidth
      const wh = screenWrap.clientHeight
      zoomTx = Math.max(ww * (1 - zoomLevel), Math.min(0, zoomTx))
      zoomTy = Math.max(wh * (1 - zoomLevel), Math.min(0, zoomTy))
    }

    // Mouse wheel â†’ zoom at cursor position
    screenWrap.addEventListener('wheel', (e) => {
      if (!sessionViewShown) return
      e.preventDefault()
      const wrapRect = screenWrap.getBoundingClientRect()
      const cx = e.clientX - wrapRect.left
      const cy = e.clientY - wrapRect.top
      const factor = e.deltaY > 0 ? 0.85 : 1.18
      const newZoom = Math.max(1.0, Math.min(4.0, zoomLevel * factor))
      if (newZoom !== zoomLevel) {
        zoomTx = cx - (cx - zoomTx) * (newZoom / zoomLevel)
        zoomTy = cy - (cy - zoomTy) * (newZoom / zoomLevel)
        zoomLevel = newZoom
        clampPan()
        applyZoom()
      }
    }, { passive: false })

    // Double-click on canvas â†’ reset zoom
    canvas.addEventListener('dblclick', () => {
      if (zoomLevel > 1.01) resetZoom()
    })

    // Zoom reset button
    zoomResetBtn.addEventListener('click', resetZoom)

    // Mouse pan (drag while zoomed)
    canvas.addEventListener('mousedown', (e) => {
      if (zoomLevel > 1.01 && e.button === 0) {
        isPanning = true
        panLastX = e.clientX; panLastY = e.clientY
        skipNextClick = false
        canvas.style.cursor = 'grabbing'
        e.preventDefault()
      }
    })
    document.addEventListener('mousemove', (e) => {
      if (!isPanning) return
      const dx = e.clientX - panLastX
      const dy = e.clientY - panLastY
      if (Math.abs(dx) + Math.abs(dy) > 3) skipNextClick = true
      zoomTx += dx; zoomTy += dy
      panLastX = e.clientX; panLastY = e.clientY
      clampPan(); applyZoom()
    })
    document.addEventListener('mouseup', () => {
      if (isPanning) {
        isPanning = false
        canvas.style.cursor = zoomLevel > 1.01 ? 'grab' : (sessionViewShown ? 'crosshair' : 'default')
      }
    })

    // Touch pinch-to-zoom
    let lastPinchDist = 0
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault()
        const dx = e.touches[0].clientX - e.touches[1].clientX
        const dy = e.touches[0].clientY - e.touches[1].clientY
        lastPinchDist = Math.hypot(dx, dy)
      }
    }, { passive: false })
    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault()
        const dx = e.touches[0].clientX - e.touches[1].clientX
        const dy = e.touches[0].clientY - e.touches[1].clientY
        const dist = Math.hypot(dx, dy)
        if (lastPinchDist > 0 && dist > 0) {
          const factor = dist / lastPinchDist
          const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2
          const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2
          const wrapRect = screenWrap.getBoundingClientRect()
          const cx = midX - wrapRect.left
          const cy = midY - wrapRect.top
          const newZoom = Math.max(1.0, Math.min(4.0, zoomLevel * factor))
          zoomTx = cx - (cx - zoomTx) * (newZoom / zoomLevel)
          zoomTy = cy - (cy - zoomTy) * (newZoom / zoomLevel)
          zoomLevel = newZoom
          clampPan(); applyZoom()
        }
        lastPinchDist = dist
      }
    }, { passive: false })
    canvas.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) lastPinchDist = 0
    })

    // â”€â”€ RTT latency (Phase 16) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Send ping every 5s; measure pong round-trip from the Android worklet.
    let pingInterval = null
    let pingTs       = 0

    function startPingInterval(wsConn) {
      stopPingInterval()
      pingInterval = setInterval(() => {
        if (wsConn && wsConn.readyState === WebSocket.OPEN) {
          pingTs = Date.now()
          wsConn.send(JSON.stringify({ type: 'ping' }) + '\n')
        }
      }, 5000)
    }

    function stopPingInterval() {
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null }
      pingTs = 0
      latencyBadgeEl.style.display = 'none'
    }

    function updateLatencyBadge(ms) {
      rttSamples.push(ms)                          // Phase 34: track RTT for session summary
      if (rttSamples.length > 60) rttSamples.shift() // keep last 60 samples (~5 min)
      latencyBadgeEl.textContent = `${ms}ms`
      latencyBadgeEl.style.color = ms < 100 ? 'var(--green)' : ms < 300 ? 'var(--amber)' : 'var(--red)'
      latencyBadgeEl.style.display = 'inline'
    }

    function updateFpsBadge(fps) {
      if (fps === null) {
        fpsEl.textContent = 'â¸ paused'
        fpsEl.className = 'fps-paused'
      } else if (fps >= 5) {
        fpsEl.textContent = `${fps.toFixed(1)} fps`
        fpsEl.className = 'fps-good'
      } else {
        fpsEl.textContent = `${fps.toFixed(1)} fps`
        fpsEl.className = 'fps-low'
      }
    }

    function schedulePauseCheck() {
      clearTimeout(fpsPauseTimer)
      fpsPauseTimer = setTimeout(() => {
        if (performance.now() - lastFrameAt > 2000) updateFpsBadge(null)
      }, 2100)
    }

    function tickFps() {
      frameCount++
      totalFrames++   // Phase 34: cumulative session frame count
      lastFrameAt = performance.now()
      schedulePauseCheck()
      const now = performance.now()
      if (now - lastFpsTs >= 1000) {
        const fps = frameCount / ((now - lastFpsTs) / 1000)
        frameCount = 0
        lastFpsTs = now
        updateFpsBadge(fps)
        checkQualityTier(fps)  // Phase 12: adaptive quality hint
      }
    }

    function hideFpsBadge() {
      fpsEl.style.display = 'none'
      fpsEl.className = ''
      clearTimeout(fpsPauseTimer)
    }

    // â”€â”€ Frame rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let sessionViewShown = false
    // Phase 32: frame drop guard â€” skip incoming frame if previous decode is still in progress
    let jpegRenderPending = false

    function renderFrame(base64jpeg) {
      if (!sessionViewShown) {
        sessionViewShown = true
        showSessionView()
        setStatus('âœ… Connected â€” receiving screen', 'connected')
        appendChat('Session started â€” say hello!', 'system')
      }

      // Phase 32: drop burst frames â€” only one Image decode in flight at a time
      if (jpegRenderPending) return
      jpegRenderPending = true

      const img = new Image()
      img.onload = () => {
        if (canvas.width !== img.width || canvas.height !== img.height) {
          canvas.width  = img.width
          canvas.height = img.height
          syncAnnotCanvasSize()  // Phase 29: keep annotation overlay in sync
        }
        ctx.drawImage(img, 0, 0)
        tickFps()
        onFrameReceived(Math.round(base64jpeg.length * 0.75))  // Phase 53: track frame for auto-recovery
        jpegRenderPending = false   // ready for next frame
      }
      img.onerror = () => { jpegRenderPending = false }  // reset on decode error too
      img.src = 'data:image/jpeg;base64,' + base64jpeg
    }

    // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let ws  = null
    let buf = ''
    let wsRetryCount  = 0
    let wsConnectUrl  = null
    const WS_MAX_RETRIES  = 5
    const WS_RETRY_DELAYS = [3000, 5000, 10000, 20000, 30000]

    function setStatus(text, cls) {
      statusEl.textContent = text
      statusEl.className   = cls || ''
    }

    // â”€â”€ Phase 74: Post-session how-to note card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const sessionNoteCard    = document.getElementById('sessionNoteCard')
    const sessionNoteText    = document.getElementById('sessionNoteText')
    const noteCharCount      = document.getElementById('noteCharCount')
    const sessionNoteSend    = document.getElementById('sessionNoteSend')
    const sessionNoteDismiss = document.getElementById('sessionNoteDismiss')

    function showSessionNoteCard() {
      sessionNoteText.value        = ''
      noteCharCount.textContent    = '0/400'
      sessionNoteCard.style.display = 'block'
      setTimeout(() => sessionNoteText.focus(), 50)
    }

    function hideSessionNoteCard() {
      sessionNoteCard.style.display = 'none'
      sessionNoteText.value         = ''
    }

    // Live char counter
    sessionNoteText.addEventListener('input', () => {
      noteCharCount.textContent = sessionNoteText.value.length + '/400'
    })

    // Ctrl+Enter sends the note
    sessionNoteText.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault()
        sessionNoteSend.click()
      }
    })

    // Send button
    sessionNoteSend.addEventListener('click', () => {
      const text = sessionNoteText.value.trim()
      if (!text) { hideSessionNoteCard(); return }
      const helperName = (document.getElementById('helperNameInput')?.value?.trim()) || 'Your helper'
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'session_note', text: text.slice(0, 400), helperName }) + '\n')
        appendStatus('ğŸ“ How-to note sent to your family member âœ“', 'info')
      } else {
        appendStatus('ğŸ“ Note not delivered â€” session already ended', 'warn')
      }
      hideSessionNoteCard()
    })

    // Dismiss button
    sessionNoteDismiss.addEventListener('click', () => hideSessionNoteCard())

    function onConnected() {
      hideSessionNoteCard()  // Phase 74: clear any leftover note card from previous session
      disconnectBtn.style.display = 'block'
      connectBtn.disabled         = true
    }

    // Phase 34: Show a brief session summary toast at the end of each session
    function showSessionSummary() {
      if (totalFrames === 0) return   // session never actually got frames â€” nothing to show
      const dur = sessionStartMs ? Math.floor((Date.now() - sessionStartMs) / 1000) : 0
      const mm  = String(Math.floor(dur / 60)).padStart(2, '0')
      const ss  = String(dur % 60).padStart(2, '0')
      const mode = sessionStreamMode === 'camera' ? 'ğŸ“· Camera' : 'ğŸ–¥ï¸ Screen Share'
      const fStr = totalFrames >= 1000
        ? `${(totalFrames / 1000).toFixed(1)}k frames`
        : `${totalFrames} frames`
      let txt = `Session ${mm}:${ss} Â· ${mode} Â· ${fStr}`
      if (rttSamples.length > 0) {
        const avg = Math.round(rttSamples.reduce((a, b) => a + b, 0) / rttSamples.length)
        const quality = avg < 100 ? 'âœ… Good' : avg < 300 ? 'âš ï¸ Fair' : 'ğŸ”´ Poor'
        txt += ` Â· ${avg}ms avg (${quality})`
      }
      const el = document.getElementById('sessionSummary')
      if (!el) return
      el.textContent = txt
      el.style.display = 'block'
      el.style.animation = 'none'
      // Re-trigger animation
      void el.offsetWidth
      el.style.animation = ''
      clearTimeout(el._hideTimer)
      el._hideTimer = setTimeout(() => { el.style.display = 'none' }, 7000)
    }

    function onDisconnected() {
      // Phase 80: clear privacy overlay on any disconnect â€” no ghost overlay after session
      hidePrivacyOverlay()
      // Phase 59: notify that session ended + hide badge
      if (window.sendDesktopNotif) window.sendDesktopNotif('FamDesk â€” Session Ended', 'The remote session has ended.', 'disconnect')
      if (window._hideNotifBadge) window._hideNotifBadge()
      showSessionSummary()  // Phase 34: show stats BEFORE state is cleared
      // Phase 74: show post-session how-to note card if a real session happened
      if (totalFrames > 0) showSessionNoteCard()
      // Phase 34: reset session stats for next session
      totalFrames      = 0
      rttSamples       = []
      sessionStreamMode = null
      // Phase 53: reset auto-recovery state
      lastFrameReceivedMs = 0
      autoRecoveryActive  = false
      autoRecoveryCount   = 0
      frameSizeHistory.length = 0
      hideSessionView()
      disconnectBtn.style.display = 'none'
      connectBtn.disabled         = false
      hideFpsBadge()
      buf = ''
      ws = null
      activeWs = null
      sessionViewShown = false
      jpegRenderPending = false   // Phase 32: reset frame drop guard on disconnect
      // Clear chat for next session
      chatMessages.innerHTML = ''
      // Clean up audio context + Phase 54: reset GainNode + mic decay
      if (audioCtx) { audioCtx.close(); audioCtx = null; audioScheduledAt = 0 }
      audioGainNode = null
      stopElderMicDecay()
      document.getElementById('elderMicGroup').style.display = 'none'
      resetElderMicLevel()  // Phase 79: hide IPC-sourced mic panel on disconnect
      document.getElementById('audioVolumeGroup').style.display = 'none'
      volumeSlider.value = 100
      volumeLabel.textContent = '100%'
      // Clean up WebCodecs decoders
      stopVideoRenderLoop()   // Phase 81: stop 15fps render loop, drain jitter queue
      if (videoDecoder) { try { videoDecoder.close() } catch(_) {} }
      videoDecoder = null; videoDecoderInit = false; videoDecoderConfig = null; renderPending = false; h264SpsPpsPrefix = null
      if (audioDecoderWC) { try { audioDecoderWC.close() } catch(_) {} }
      audioDecoderWC = null; audioDecoderInit = false
      muted = false
      muteBtn.querySelector('.ctrl-icon').textContent = 'ğŸ”Š'
      muteBtn.classList.remove('active')
      // Phase 10: stop browser mic capture
      stopBrowserMic()
      micMuted = false
      micMuteBtn.querySelector('.ctrl-icon').textContent = 'ğŸ™ï¸'
      micMuteBtn.classList.remove('active')
      // Phase 11: reset pointer cursor + hide hint (Phase 16: also clear zoom transform)
      document.getElementById('screen').style.cursor = 'default'
      document.getElementById('screen').style.transform = ''
      document.getElementById('pointerHint').style.display = 'none'
      // Phase 12: reset adaptive quality state
      resetQualityTier()
      // Phase 16: reset zoom + stop latency ping
      resetZoom()
      stopPingInterval()
      // Phase 24: stop QR scanner if active + restore scan button
      if (typeof stopQrScanner === 'function') stopQrScanner()
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        document.getElementById('scanQrBtn').style.display = 'inline'
      }
      // Phase 27: stop session timer
      stopSessionTimer()
      document.getElementById('sessionTimer').style.display = 'none'
      document.getElementById('pastePanel').style.display = 'none'
      document.getElementById('quickMsgPanel').style.display = 'none'  // Phase 60
      // Reset annotation state (Phase 29)
      annotating = false
      annotateBtn.classList.remove('active')
      annotationCanvas.style.pointerEvents = 'none'
      document.getElementById('screen').style.pointerEvents = 'all'
      clearAnnotationsLocal()
      // Phase 33: stop helper webcam PiP
      stopHelperCam()
      document.getElementById('helperCamBtn').style.display = 'none'
      // Phase 42: stop helper screen share
      stopHelperScreenShare()
      document.getElementById('helperScreenBtn').style.display = 'none'
      // Phase 51: hide Refresh + Quality selector
      document.getElementById('refreshBtn').style.display = 'none'
      document.getElementById('qualitySelector').style.display = 'none'
      manualQualityOverride = false
      // Phase 64: hide Send Image button
      document.getElementById('sendImageBtn').style.display = 'none'
      // Phase 70: hide Laser Pointer button + reset state
      document.getElementById('laserBtn').style.display = 'none'
      if (typeof resetLaserState === 'function') resetLaserState()
      // Phase 66: hide Shortcuts Help button + close modal if open
      document.getElementById('shortcutsHelpBtn').style.display = 'none'
      document.getElementById('shortcutsModal').style.display = 'none'
      // Phase 65 / Phase 71: hide Settings Launcher in drawer on session end
      const slg2 = document.getElementById('settingsLauncherGroup')
      if (slg2) { slg2.style.display = 'none' }
      document.getElementById('toolbarDrawer').classList.remove('open') // Phase 71
      // Phase 68: reset typing indicator + clear sentMessages map
      handleTypingEvent(false)
      Object.keys(sentMessages).forEach(k => delete sentMessages[k])
    }

    // â”€â”€ Connect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function openWebSocket(url) {
      ws = new WebSocket(url)

      ws.onopen = () => {
        activeWs = ws
        wsRetryCount = 0
        onConnected()
        startBrowserMic(ws)  // Phase 10: start capturing mic now that WS is open
        startPingInterval(ws) // Phase 16: RTT latency measurement
        // Show session view immediately so user knows they're connected and waiting
        if (!sessionViewShown) {
          sessionViewShown = true
          showSessionView()
          setStatus('â³ Connected â€” waiting for screen share to startâ€¦', 'waiting')
          appendChat('Connected! Ask them to tap "Get Help" if they haven\'t yet.', 'system')
        }
      }

      ws.onmessage = (evt) => {
        const raw = typeof evt.data === 'string' ? evt.data : null
        if (!raw) return

        buf += raw
        const lines = buf.split('\n')
        buf = lines.pop()

        for (const line of lines) {
          const trimmed = line.trim()
          if (!trimmed) continue
          let msg
          try { msg = JSON.parse(trimmed) } catch (e) { continue }

          if (msg.type === 'frame' && msg.data) {
            renderFrame(msg.data)

          } else if (msg.type === 'video_frame' && msg.data) {
            // Phase 7: Camera frame â€” render to same canvas as screen frames
            renderFrame(msg.data)

          } else if (msg.type === 'stream_info') {
            // Phase 7: Mode announcement â€” update badge
            sessionStreamMode = msg.mode   // Phase 34: capture for session summary
            const modeLabel = msg.mode === 'camera' ? 'ğŸ“· Camera' : 'ğŸ–¥ï¸ Screen Share'
            const modeEl = document.getElementById('streamMode')
            if (modeEl) {
              modeEl.textContent = modeLabel
              if (sessionViewShown) modeEl.style.display = 'block'
            }
            // Phase 78: show/hide snap button based on camera mode
            const snapBtnEl = document.getElementById('snapBtn')
            if (snapBtnEl) snapBtnEl.style.display = msg.mode === 'camera' ? 'flex' : 'none'
            // Reset torch badge when exiting camera mode
            if (msg.mode !== 'camera') {
              const torchBadgeEl = document.getElementById('torchBadge')
              if (torchBadgeEl) torchBadgeEl.style.display = 'none'
            }

          } else if (msg.type === 'audio' && msg.data) {
            // Phase 8: PCM16 audio chunk from user mic â†’ Web Audio API playback
            const sr = msg.sampleRate || 16000
            try {
              playPcm16(msg.data, sr)
            } catch (e) {
              // Silently absorb audio decode errors (malformed chunk)
              if (window.__audioErrCount === undefined) window.__audioErrCount = 0
              window.__audioErrCount++
              if (window.__audioErrCount % 50 === 1) console.warn('Audio decode err (50-count):', e)
            }

          } else if (msg.type === 'codec_init') {
            // Initialize decoders when Android sends codec parameters
            console.log('[FamDesk] codec_init received â€” video:', !!msg.video, 'audio:', !!msg.audio,
              msg.video ? 'codec:' + msg.video.codec + ' sps:' + (msg.video.sps||'').length + ' pps:' + (msg.video.pps||'').length : '')
            if (msg.video) {
              initVideoDecoder(msg.video)
            }
            if (msg.audio && typeof AudioDecoder !== 'undefined') {
              initAudioDecoder(msg.audio)
            }

          } else if (msg.type === 'h264_frame') {
            if (!window._h264Count) window._h264Count = 0
            if (++window._h264Count <= 5 || window._h264Count % 100 === 0)
              console.log('[FamDesk] h264_frame #' + window._h264Count + ' key:' + msg.keyframe + ' len:' + (msg.data||'').length + ' decoderInit:' + videoDecoderInit)
            if (videoDecoderInit && videoDecoder && videoDecoder.state !== 'closed') {
              decodeH264Frame(msg)
            } else if (!videoDecoderInit) {
              // codec_init hasn't arrived yet (race condition: reconnect before Android re-sends it).
              // DON'T try to decode without SPS/PPS â€” it will silently fail â†’ black screen.
              // Instead: ask Android to re-send codec_init. Debounced to once per 2s.
              const now = Date.now()
              if (!window._codecInitRequestedAt || now - window._codecInitRequestedAt > 2000) {
                window._codecInitRequestedAt = now
                console.warn('[WebCodecs] h264_frame before codec_init â€” requesting re-send from Android')
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'request_codec_init' }) + '\n')
                }
              }
              // Drop this frame â€” we'll start decoding cleanly once codec_init arrives
            }

          } else if (msg.type === 'aac_frame') {
            if (audioDecoderInit && audioDecoderWC && audioDecoderWC.state !== 'closed') {
              try {
                const data = Uint8Array.from(atob(msg.data), c => c.charCodeAt(0))
                audioDecoderWC.decode(new EncodedAudioChunk({
                  type: 'key',
                  timestamp: (msg.pts || 0) * 1000,
                  data: data
                }))
              } catch(e) { console.warn('[WebCodecs] audio decode error:', e) }
            }

          } else if (msg.type === 'chat' || msg.type === 'chat_received') {
            const label = 'User'
            appendChat(msg.text || '', 'peer', label)

          } else if (msg.type === 'typing') {
            // Phase 68: elder typing indicator
            handleTypingEvent(msg.active)

          } else if (msg.type === 'read_receipt') {
            // Phase 68: elder read the helper's message(s) â€” mark âœ“âœ“ in accent color
            Object.keys(sentMessages).forEach(sentTs => {
              if (parseInt(sentTs) <= msg.ts) {
                const span = sentMessages[sentTs]
                if (span) {
                  span.textContent = 'âœ“âœ“'
                  span.title = 'Read'
                  span.classList.add('read')
                }
                delete sentMessages[sentTs]
              }
            })

          } else if (msg.type === 'connected') {
            if (!sessionViewShown) {
              sessionViewShown = true
              showSessionView()
              setStatus('âœ… Connected â€” waiting for screenâ€¦', 'connected')
              appendChat('Session started â€” say hello!', 'system')
            }

          } else if (msg.type === 'disconnected') {
            setStatus('ğŸ“´ User disconnected â€” may reconnectâ€¦', 'waiting')
            appendChat('User disconnected â€” waiting for reconnectâ€¦', 'system')
            // Phase 59: alert helper even when backgrounded
            if (window.sendDesktopNotif) window.sendDesktopNotif('FamDesk âš ï¸ User Disconnected', 'The person you\'re helping has dropped â€” may reconnect shortly.', 'disconnect')

          } else if (msg.type === 'reconnecting') {
            setStatus(`ğŸ”„ User reconnecting (attempt ${msg.attempt || 1})â€¦`, 'waiting')

          } else if (msg.type === 'session_ended') {
            setStatus('âŒ Session ended â€” reload to start a new session.', 'error')
            appendChat('Session ended by user.', 'system')
            onDisconnected()

          } else if (msg.type === 'ping') {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'pong' }) + '\n')
            }

          } else if (msg.type === 'pong') {
            // Phase 16: measure RTT from our outgoing ping â†’ Android â†’ back
            if (pingTs > 0) {
              updateLatencyBadge(Date.now() - pingTs)
              pingTs = 0
            }

          } else if (msg.type === 'debug_log') {
            // Phase 56: real-time Android debug log forwarded through Hyperswarm
            appendDebugLog(msg.tag || '?', msg.msg || '', msg.ts)
            console.log(`[DBG ${msg.tag}] ${msg.msg}`)

          } else if (msg.type === 'annotation') {
            // Phase 29: annotation looped back (graceful no-op â€” user receives via Kotlin)
          } else if (msg.type === 'clear_annotations') {
            clearAnnotationsLocal()
          } else if (msg.type === 'battery_status') {
            // Phase 54: elder battery level + charging state
            updateBatteryBadge(msg.level, msg.charging)
          } else if (msg.type === 'network_status') {
            // Phase 54: elder network type (wifi / cellular + generation)
            updateNetworkBadge(msg.netType, msg.level, msg.generation)
          } else if (msg.type === 'torch_state') {
            // Phase 78: elder torch toggled â€” show/hide torch badge in header
            const tb = document.getElementById('torchBadge')
            if (tb) tb.style.display = msg.enabled ? 'inline' : 'none'
          } else if (msg.type === 'elder_audio_level') {
            // Phase 79: elder mic RMS level from Android IPC
            updateElderMicPanel(msg.level)

          } else if (msg.type === 'screen_privacy_active') {
            // Phase 80: FLAG_SECURE â€” elder opened banking/payment app; show privacy overlay
            showPrivacyOverlay()
          } else if (msg.type === 'screen_privacy_cleared') {
            // Phase 80: FLAG_SECURE cleared â€” elder navigated back; hide privacy overlay
            hidePrivacyOverlay()

          } else if (msg.type === 'camera_snapshot') {
            // Phase 78: high-res snapshot from elder's camera â€” trigger download
            if (msg.data) {
              try {
                const a = document.createElement('a')
                a.href = 'data:image/jpeg;base64,' + msg.data
                a.download = 'famdesk-snapshot-' + Date.now() + '.jpg'
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                appendChat(`ğŸ“¸ Snapshot saved â€” ${msg.width || '?'}Ã—${msg.height || '?'}`, 'system')
                const snapBtnEl = document.getElementById('snapBtn')
                if (snapBtnEl) snapBtnEl.disabled = false
              } catch (e) {
                appendChat('âŒ Snapshot download failed: ' + e.message, 'system')
              }
            }
          } else if (msg.type === 'error') {
            setStatus('âŒ Gateway error: ' + (msg.message || 'unknown'), 'error')
          }
        }
      }

      ws.onclose = (evt) => {
        ws  = null
        activeWs = null
        if (evt.code === 1000 || evt.wasClean) {
          setStatus('Session ended.', '')
          onDisconnected()
          return
        }
        if (wsRetryCount < WS_MAX_RETRIES && wsConnectUrl) {
          const delay = WS_RETRY_DELAYS[wsRetryCount] || 30000
          wsRetryCount++
          setStatus(`ğŸ”„ Disconnected â€” reconnecting in ${delay/1000}s (attempt ${wsRetryCount})â€¦`, 'waiting')
          if (sessionViewShown) appendChat(`Reconnecting in ${delay/1000}sâ€¦`, 'system')
          setTimeout(() => {
            if (wsConnectUrl) openWebSocket(wsConnectUrl)
          }, delay)
        } else {
          setStatus('âŒ Session ended â€” reload to try again.', 'error')
          onDisconnected()
        }
      }

      ws.onerror = () => {
        setStatus(`âŒ Cannot reach gateway at ${GATEWAY_WS.replace(/wss?:\/\//,'').split('/')[0]} â€” is MINI online?`, 'error')
        // onclose fires next and handles retry/disconnect â€” but make sure button is
        // not left disabled if onclose immediately calls onDisconnected():
        wsConnectUrl = null // prevent retry loop â€” let user re-scan or re-type
        wsRetryCount = WS_MAX_RETRIES
      }
    }

    async function connect() {
      const code = codeInput.value.trim().toUpperCase()
      if (code.length < 4) {
        setStatus('âš ï¸ Enter a valid 8-character code.', 'error')
        return
      }
      const gwHost = GATEWAY_WS.replace(/wss?:\/\//, '').split('/')[0]
      setStatus(`â³ Connecting to gateway: ${gwHost}`, 'waiting')
      connectBtn.disabled = true
      getAudioCtx()  // create AudioContext during user gesture â€” avoids autoplay block

      // Phase 10: request mic access during user gesture (avoids permission dialog surprise later)
      try {
        // Phase 37: explicit AEC + noise suppression + AGC constraints (cross-browser reliable)
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('page needs HTTPS for microphone access')
        }
        window._micStream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true,
                   sampleRate: 16000, channelCount: 1 },
          video: false
        })
        console.log('[browser-mic] Mic permission granted (AEC+NS+AGC enabled)')
      } catch (e) {
        console.warn('[browser-mic] Permission denied or unavailable:', e.message)
        window._micStream = null
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          appendChat('\u26a0\ufe0f Microphone unavailable \u2014 helper.html must be opened via HTTPS for voice. Screen share and chat work normally.', 'system')
        }
      }

      let topicHex
      try {
        topicHex = await codeToTopicHex(code)
      } catch (e) {
        setStatus('âŒ Crypto error: ' + e.message, 'error')
        connectBtn.disabled = false
        return
      }

      wsConnectUrl = `${GATEWAY_WS}?topic=${topicHex}`
      wsRetryCount = 0
      openWebSocket(wsConnectUrl)
    }

    connectBtn.addEventListener('click', connect)
    codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') connect() })
    codeInput.addEventListener('input',   () => { codeInput.value = codeInput.value.toUpperCase() })

    disconnectBtn.addEventListener('click', () => {
      wsConnectUrl  = null
      wsRetryCount  = WS_MAX_RETRIES
      if (ws) { ws.close(1000, 'User ended session') }
      setStatus('Session ended.', '')
      onDisconnected()
    })

    // â”€â”€ Phase 36 v2: Helper Webcam â€” WebCodecs VP8/H.264 encode â†’ user Android PiP â”€â”€
    ;(function() {
      const helperCamPip    = document.getElementById('helperCamPip')
      const helperCamCanvas = document.getElementById('helperCamCanvas')
      const helperCamBtn    = document.getElementById('helperCamBtn')
      let helperCamStream   = null
      let helperCamOn       = false
      let helperCamInterval    = null  // JPEG fallback setInterval
      let helperCamEncoder     = null  // WebCodecs VideoEncoder instance
      let helperCamTrackReader = null  // MediaStreamTrackProcessor reader
      let helperCamPtsMs       = 0     // running PTS counter (ms)
      let helperCamKeyInterval = null  // periodic forced keyframe timer
      let helperCamUseWebCodecs = false

      // Frame rate: 5fps = 200ms interval. Quality 0.55 â‰ˆ 50KB/frame at 320Ã—240.
      const CAM_FPS_MS   = 200
      const CAM_QUALITY  = 0.55
      const CAM_W        = 320
      const CAM_H        = 240

      // â”€â”€ HTTPS guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // getUserMedia requires a secure context (https:// or localhost).
      // On plain http:// from mobile browsers, mediaDevices is undefined.
      // We show the button only when the API is available (checked in showSessionView).
      // If unavailable: button stays hidden, no warning needed.

      // â”€â”€ Frame sending loop â€” WebCodecs or JPEG fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function startFrameLoop() {
        if (helperCamInterval || helperCamEncoder) return // already running

        // Detect WebCodecs support
        const hasWebCodecs = (typeof VideoEncoder !== 'undefined' &&
                              typeof MediaStreamTrackProcessor !== 'undefined')

        if (hasWebCodecs) {
          startWebCodecsLoop()
        } else {
          startJpegLoop() // fallback
        }
      }

      // â”€â”€ WebCodecs path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      async function startWebCodecsLoop() {
        const track = helperCamStream.getVideoTracks()[0]
        if (!track) { startJpegLoop(); return }

        // Determine codec: try VP8, fallback to H.264
        let chosenCodec = 'vp8'
        let codecStr = 'vp8'
        try {
          const support = await VideoEncoder.isConfigSupported({
            codec: 'vp8', width: CAM_W, height: CAM_H, bitrate: 200000, framerate: 15
          })
          if (!support.supported) throw new Error('vp8 not supported')
        } catch {
          chosenCodec = 'h264'
          codecStr = 'avc1.42001f'  // H.264 Baseline Level 3.1
        }

        helperCamEncoder = new VideoEncoder({
          output: (chunk, meta) => {
            const buf = new Uint8Array(chunk.byteLength)
            chunk.copyTo(buf)
            const b64 = btoa(String.fromCharCode(...buf))
            const msg = JSON.stringify({
              type: 'helper_video_frame',
              keyframe: chunk.type === 'key',
              pts: Math.round(chunk.timestamp / 1000), // Î¼s â†’ ms
              data: b64
            }) + '\n'
            if (ws && ws.readyState === WebSocket.OPEN) ws.send(msg)
          },
          error: (e) => {
            console.warn('[WebCodecs encode] error, falling back to JPEG:', e)
            helperCamEncoder = null
            startJpegLoop()
          }
        })

        try {
          helperCamEncoder.configure({
            codec: codecStr,
            width: CAM_W,
            height: CAM_H,
            bitrate: 200_000,
            framerate: 15,
            latencyMode: 'realtime'
          })
        } catch (e) {
          console.warn('[WebCodecs configure] failed, falling back to JPEG:', e)
          helperCamEncoder.close()
          helperCamEncoder = null
          startJpegLoop()
          return
        }

        // Send codec init to Android
        const initMsg = JSON.stringify({
          type: 'helper_codec_init',
          codec: chosenCodec,
          width: CAM_W,
          height: CAM_H,
          framerate: 15
        }) + '\n'
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(initMsg)

        helperCamUseWebCodecs = true
        helperCamPtsMs = 0

        // Force keyframe every 2 seconds for resilience
        helperCamKeyInterval = setInterval(() => {
          if (helperCamEncoder && helperCamEncoder.state === 'configured') {
            helperCamEncoder.encode(
              new VideoFrame(helperCamPip, { timestamp: helperCamPtsMs * 1000 }),
              { keyFrame: true }
            )
            helperCamPtsMs += Math.round(1000 / 15)
          }
        }, 2000)

        // Feed frames from track
        const processor = new MediaStreamTrackProcessor({ track })
        helperCamTrackReader = processor.readable.getReader()

        ;(async () => {
          try {
            while (true) {
              const { value: frame, done } = await helperCamTrackReader.read()
              if (done || !helperCamEncoder) break
              if (helperCamEncoder.encodeQueueSize < 3) {
                helperCamEncoder.encode(frame, { keyFrame: false })
              }
              frame.close()
            }
          } catch (e) {
            if (e.name !== 'AbortError') console.warn('[WebCodecs reader]', e)
          }
        })()
      }

      // â”€â”€ JPEG fallback path (original implementation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function startJpegLoop() {
        if (helperCamInterval) return
        const ctx = helperCamCanvas.getContext('2d')
        helperCamInterval = setInterval(() => {
          if (!helperCamOn || !ws || ws.readyState !== WebSocket.OPEN) return
          if (helperCamPip.videoWidth === 0) return  // video not ready yet
          helperCamCanvas.width  = CAM_W
          helperCamCanvas.height = CAM_H
          ctx.drawImage(helperCamPip, 0, 0, CAM_W, CAM_H)
          const dataUrl = helperCamCanvas.toDataURL('image/jpeg', CAM_QUALITY)
          const base64  = dataUrl.slice(dataUrl.indexOf(',') + 1)
          ws.send(JSON.stringify({ type: 'helper_video', data: base64, ts: Date.now() }) + '\n')
        }, CAM_FPS_MS)
      }

      function stopFrameLoop() {
        // WebCodecs path
        if (helperCamTrackReader) {
          helperCamTrackReader.cancel().catch(() => {})
          helperCamTrackReader = null
        }
        if (helperCamEncoder) {
          if (helperCamEncoder.state === 'configured') helperCamEncoder.flush().catch(() => {})
          helperCamEncoder.close()
          helperCamEncoder = null
        }
        if (helperCamKeyInterval) {
          clearInterval(helperCamKeyInterval)
          helperCamKeyInterval = null
        }
        helperCamUseWebCodecs = false

        // JPEG path
        if (helperCamInterval) {
          clearInterval(helperCamInterval)
          helperCamInterval = null
        }

        // Notify user
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'helper_video_stop' }) + '\n')
        }
      }

      // â”€â”€ Start/stop helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      window.startHelperCam = async function() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          // Shouldn't reach here (button hidden), but guard anyway
          return
        }
        try {
          helperCamStream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: CAM_W }, height: { ideal: CAM_H }, facingMode: 'user' },
            audio: false
          })
          helperCamPip.srcObject = helperCamStream
          helperCamPip.classList.add('pip-active')
          helperCamOn = true
          helperCamBtn.classList.add('active')
          helperCamBtn.querySelector('.ctrl-icon').textContent = 'ğŸ“¹'
          helperCamBtn.title = 'Hide your webcam (they can see your face â€” tap to stop)'
          startFrameLoop()
        } catch (e) {
          console.warn('[helperCam] getUserMedia failed:', e.message)
          // Graceful degradation: if user denies or device unavailable, do nothing
          if (e.name === 'NotAllowedError') {
            helperCamBtn.title = 'Camera permission denied â€” check browser settings'
          } else if (window.location.protocol === 'http:' && window.location.hostname !== 'localhost') {
            helperCamBtn.title = 'âš ï¸ Webcam requires HTTPS â€” use the tunnel URL, not the LAN IP'
            helperCamBtn.disabled = true
          }
        }
      }

      window.stopHelperCam = function() {
        stopFrameLoop()
        if (helperCamStream) {
          helperCamStream.getTracks().forEach(t => t.stop())
          helperCamStream = null
        }
        helperCamPip.srcObject = null
        helperCamPip.classList.remove('pip-active')
        helperCamOn = false
        helperCamBtn.classList.remove('active')
        helperCamBtn.querySelector('.ctrl-icon').textContent = 'ğŸ“¹'
        helperCamBtn.title = 'Show your face to the user (requires HTTPS for mobile)'
      }

      helperCamBtn.addEventListener('click', () => {
        if (helperCamOn) stopHelperCam()
        else startHelperCam()
      })

      // â”€â”€ Drag to reposition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Allows helper to drag the PiP to any corner for better visibility.
      let pipDragging = false
      let pipOffX = 0, pipOffY = 0

      helperCamPip.addEventListener('mousedown', (e) => {
        pipDragging = true
        const r = helperCamPip.getBoundingClientRect()
        pipOffX = e.clientX - r.left
        pipOffY = e.clientY - r.top
        helperCamPip.style.cursor = 'grabbing'
        e.preventDefault()
      })
      document.addEventListener('mousemove', (e) => {
        if (!pipDragging) return
        const wrap = document.getElementById('screenWrap')
        const wr   = wrap.getBoundingClientRect()
        const vw   = helperCamPip.offsetWidth
        const vh   = helperCamPip.offsetHeight
        let nx = e.clientX - wr.left - pipOffX
        let ny = e.clientY - wr.top  - pipOffY
        // Clamp inside screenWrap
        nx = Math.max(0, Math.min(wr.width  - vw, nx))
        ny = Math.max(0, Math.min(wr.height - vh, ny))
        helperCamPip.style.right = 'auto'
        helperCamPip.style.bottom = 'auto'
        helperCamPip.style.top  = ny + 'px'
        helperCamPip.style.left = nx + 'px'
      })
      document.addEventListener('mouseup', () => {
        if (!pipDragging) return
        pipDragging = false
        helperCamPip.style.cursor = 'move'
      })

      // Touch drag (mobile helper)
      helperCamPip.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 1) return
        pipDragging = true
        const r  = helperCamPip.getBoundingClientRect()
        pipOffX  = e.touches[0].clientX - r.left
        pipOffY  = e.touches[0].clientY - r.top
        e.preventDefault()
      }, { passive: false })
      document.addEventListener('touchmove', (e) => {
        if (!pipDragging || !e.touches.length) return
        const wrap = document.getElementById('screenWrap')
        const wr   = wrap.getBoundingClientRect()
        const vw   = helperCamPip.offsetWidth
        const vh   = helperCamPip.offsetHeight
        let nx = e.touches[0].clientX - wr.left - pipOffX
        let ny = e.touches[0].clientY - wr.top  - pipOffY
        nx = Math.max(0, Math.min(wr.width  - vw, nx))
        ny = Math.max(0, Math.min(wr.height - vh, ny))
        helperCamPip.style.right = 'auto'
        helperCamPip.style.bottom = 'auto'
        helperCamPip.style.top  = ny + 'px'
        helperCamPip.style.left = nx + 'px'
        e.preventDefault()
      }, { passive: false })
      document.addEventListener('touchend', () => { pipDragging = false })
    })()

    // â”€â”€ Phase 42: Helper Screen Share â€” getDisplayMedia â†’ WebCodecs VP8/H.264 â†’ user Android overlay â”€â”€
    ;(function() {
      const helperScreenBtn = document.getElementById('helperScreenBtn')
      let helperScreenStream   = null
      let helperScreenEncoder  = null
      let helperScreenInterval = null  // JPEG fallback setInterval
      let helperScreenCodec    = null
      let helperScreenFrameCount = 0
      let helperScreenTrackReader = null
      let helperScreenKeyInterval = null
      let helperScreenPtsMs = 0
      let helperScreenOn = false

      const SCR_W = 1280
      const SCR_H = 720
      const SCR_FPS = 10
      const SCR_BITRATE = 500_000
      const SCR_JPEG_QUALITY = 0.5
      const SCR_JPEG_INTERVAL_MS = 200  // 5fps JPEG fallback

      function startScreenFrameLoop() {
        if (helperScreenEncoder || helperScreenInterval) return

        const hasWebCodecs = (typeof VideoEncoder !== 'undefined' &&
                              typeof MediaStreamTrackProcessor !== 'undefined')
        if (hasWebCodecs) {
          startScreenWebCodecsLoop()
        } else {
          startScreenJpegLoop()
        }
      }

      async function startScreenWebCodecsLoop() {
        const track = helperScreenStream.getVideoTracks()[0]
        if (!track) { startScreenJpegLoop(); return }

        let chosenCodec = 'vp8'
        let codecStr = 'vp8'
        try {
          const support = await VideoEncoder.isConfigSupported({
            codec: 'vp8', width: SCR_W, height: SCR_H, bitrate: SCR_BITRATE, framerate: SCR_FPS
          })
          if (!support.supported) throw new Error('vp8 not supported')
        } catch {
          chosenCodec = 'h264'
          codecStr = 'avc1.42001f'
        }

        helperScreenCodec = chosenCodec

        helperScreenEncoder = new VideoEncoder({
          output: (chunk, meta) => {
            const buf = new Uint8Array(chunk.byteLength)
            chunk.copyTo(buf)
            const b64 = btoa(String.fromCharCode(...buf))
            const msg = JSON.stringify({
              type: 'helper_screen_frame',
              keyframe: chunk.type === 'key',
              ts: Math.round(chunk.timestamp / 1000),
              data: b64
            }) + '\n'
            if (ws && ws.readyState === WebSocket.OPEN) ws.send(msg)
          },
          error: (e) => {
            console.warn('[ScreenShare WebCodecs] error, falling back to JPEG:', e)
            helperScreenEncoder = null
            startScreenJpegLoop()
          }
        })

        try {
          helperScreenEncoder.configure({
            codec: codecStr,
            width: SCR_W,
            height: SCR_H,
            bitrate: SCR_BITRATE,
            framerate: SCR_FPS,
            latencyMode: 'realtime'
          })
        } catch (e) {
          console.warn('[ScreenShare WebCodecs] configure failed, JPEG fallback:', e)
          helperScreenEncoder.close()
          helperScreenEncoder = null
          startScreenJpegLoop()
          return
        }

        // Send init message
        const initMsg = JSON.stringify({
          type: 'helper_screen_init',
          codec: chosenCodec,
          width: SCR_W,
          height: SCR_H
        }) + '\n'
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(initMsg)

        helperScreenPtsMs = 0

        // Force keyframe every 2 seconds
        helperScreenKeyInterval = setInterval(() => {
          if (helperScreenEncoder && helperScreenEncoder.state === 'configured' && helperScreenStream) {
            try {
              const video = document.createElement('video')
              // Use canvas to capture a frame for keyframe forcing
              // Actually, use track directly via VideoFrame from track
            } catch (_) {}
          }
        }, 2000)

        // Feed frames from track
        const processor = new MediaStreamTrackProcessor({ track })
        helperScreenTrackReader = processor.readable.getReader()

        ;(async () => {
          let framesSinceKey = 0
          try {
            while (true) {
              const { value: frame, done } = await helperScreenTrackReader.read()
              if (done || !helperScreenEncoder) break
              if (helperScreenEncoder.encodeQueueSize < 3) {
                const forceKey = (framesSinceKey === 0 || framesSinceKey >= SCR_FPS * 2)
                helperScreenEncoder.encode(frame, { keyFrame: forceKey })
                if (forceKey) framesSinceKey = 0
                framesSinceKey++
              }
              frame.close()
            }
          } catch (e) {
            if (e.name !== 'AbortError') console.warn('[ScreenShare reader]', e)
          }
        })()
      }

      function startScreenJpegLoop() {
        if (helperScreenInterval) return
        const canvas = document.createElement('canvas')
        canvas.width = SCR_W
        canvas.height = SCR_H
        const cctx = canvas.getContext('2d')
        const video = document.createElement('video')
        video.srcObject = helperScreenStream
        video.muted = true
        video.play().catch(() => {})

        // Send init for JPEG fallback
        const initMsg = JSON.stringify({
          type: 'helper_screen_init',
          codec: 'jpeg',
          width: SCR_W,
          height: SCR_H
        }) + '\n'
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(initMsg)

        helperScreenInterval = setInterval(() => {
          if (!helperScreenOn || !ws || ws.readyState !== WebSocket.OPEN) return
          if (video.videoWidth === 0) return
          cctx.drawImage(video, 0, 0, SCR_W, SCR_H)
          const dataUrl = canvas.toDataURL('image/jpeg', SCR_JPEG_QUALITY)
          const base64 = dataUrl.slice(dataUrl.indexOf(',') + 1)
          ws.send(JSON.stringify({
            type: 'helper_screen_frame',
            data: base64,
            ts: Date.now(),
            keyframe: true
          }) + '\n')
        }, SCR_JPEG_INTERVAL_MS)
      }

      function stopScreenFrameLoop() {
        if (helperScreenTrackReader) {
          helperScreenTrackReader.cancel().catch(() => {})
          helperScreenTrackReader = null
        }
        if (helperScreenEncoder) {
          if (helperScreenEncoder.state === 'configured') helperScreenEncoder.flush().catch(() => {})
          helperScreenEncoder.close()
          helperScreenEncoder = null
        }
        if (helperScreenKeyInterval) {
          clearInterval(helperScreenKeyInterval)
          helperScreenKeyInterval = null
        }
        if (helperScreenInterval) {
          clearInterval(helperScreenInterval)
          helperScreenInterval = null
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'helper_screen_stop' }) + '\n')
        }
      }

      window.startHelperScreenShare = async function() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) return
        // HTTPS guard
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
          alert('Screen sharing requires HTTPS. Use the tunnel URL, not the LAN IP.')
          return
        }
        try {
          helperScreenStream = await navigator.mediaDevices.getDisplayMedia({
            video: { width: { ideal: SCR_W }, height: { ideal: SCR_H }, frameRate: { ideal: SCR_FPS } },
            audio: false
          })
          // Handle user clicking "Stop sharing" in browser UI
          helperScreenStream.getVideoTracks()[0].addEventListener('ended', () => {
            stopHelperScreenShare()
          })
          helperScreenOn = true
          helperScreenBtn.classList.add('active')
          helperScreenBtn.querySelector('.ctrl-icon').textContent = 'ğŸ“º'
          helperScreenBtn.title = 'Stop sharing your screen (they can see your desktop)'
          startScreenFrameLoop()
        } catch (e) {
          console.warn('[ScreenShare] getDisplayMedia failed:', e.message)
          if (e.name === 'NotAllowedError') {
            helperScreenBtn.title = 'Screen share permission denied'
          }
        }
      }

      window.stopHelperScreenShare = function() {
        stopScreenFrameLoop()
        if (helperScreenStream) {
          helperScreenStream.getTracks().forEach(t => t.stop())
          helperScreenStream = null
        }
        helperScreenOn = false
        helperScreenBtn.classList.remove('active')
        helperScreenBtn.querySelector('.ctrl-icon').textContent = 'ğŸ“º'
        helperScreenBtn.title = 'Share your screen â€” they can see your desktop (requires HTTPS)'
        helperScreenCodec = null
        helperScreenFrameCount = 0
      }

      helperScreenBtn.addEventListener('click', () => {
        if (helperScreenOn) stopHelperScreenShare()
        else startHelperScreenShare()
      })
    })()

    // â”€â”€ Phase 59: Desktop Notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ;(function() {
      const NOTIF_KEY = 'famdesk_notif_pref'  // 'on' | 'off'
      const notifRow       = document.getElementById('notifRow')
      const notifIcon      = document.getElementById('notifIcon')
      const notifText      = document.getElementById('notifText')
      const notifEnableBtn = document.getElementById('notifEnableBtn')
      const notifBadge     = document.getElementById('notifSessionBadge')

      // Are desktop notifications available?
      const notifSupported = ('Notification' in window)

      function notifGranted() {
        return notifSupported && Notification.permission === 'granted'
      }

      // Update connect-card row UI to reflect current permission state
      function refreshNotifUI() {
        if (!notifSupported) {
          notifRow.style.display = 'none'
          return
        }
        notifRow.style.display = 'flex'
        if (Notification.permission === 'granted') {
          notifRow.className = 'notif-granted'
          notifIcon.textContent = 'ğŸ””'
          notifText.textContent = 'Notifications on â€” you\'ll be alerted if you switch tabs.'
          notifEnableBtn.style.display = 'none'
          localStorage.setItem(NOTIF_KEY, 'on')
        } else if (Notification.permission === 'denied') {
          notifRow.className = 'notif-denied'
          notifIcon.textContent = 'ğŸ”•'
          notifText.textContent = 'Notifications blocked â€” allow them in browser settings to get alerts.'
          notifEnableBtn.style.display = 'none'
        } else {
          // 'default' â€” not yet asked
          notifRow.className = ''
          notifIcon.textContent = 'ğŸ””'
          notifText.textContent = 'Get notified when the session starts or they send a message.'
          notifEnableBtn.style.display = 'inline-block'
        }
      }

      // Update top-bar badge visibility
      function refreshNotifBadge() {
        if (!notifBadge) return
        if (notifGranted()) {
          notifBadge.classList.add('notif-on')
          notifBadge.title = 'Desktop notifications on â€” you\'ll get alerts when backgrounded'
        } else {
          notifBadge.classList.remove('notif-on')
          notifBadge.title = 'Desktop notifications off'
        }
      }

      // Show the badge in session view
      window._showNotifBadge = function() {
        if (notifBadge) {
          notifBadge.style.display = 'inline-block'
          refreshNotifBadge()
        }
      }
      window._hideNotifBadge = function() {
        if (notifBadge) notifBadge.style.display = 'none'
      }

      // Request permission (must be called from user gesture)
      async function requestNotifPermission() {
        if (!notifSupported) return
        try {
          const result = await Notification.requestPermission()
          refreshNotifUI()
          if (result === 'granted') {
            // Send a test notification so user knows it's working
            sendDesktopNotif('FamDesk ğŸ””', 'Notifications active â€” you\'ll be alerted here when backgrounded.', 'test')
          }
        } catch (e) {
          console.warn('[notif] requestPermission error:', e)
        }
      }

      notifEnableBtn.addEventListener('click', requestNotifPermission)

      // â”€â”€ Core notification sender â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Exported to window so other parts of the code can call it
      window.sendDesktopNotif = function(title, body, tag) {
        if (!notifGranted()) return
        // Only show if document is not visible (backgrounded or minimized)
        // Also allow 'force' tag to always fire (e.g. session start)
        if (tag !== 'force' && document.visibilityState === 'visible') return
        try {
          const n = new Notification(title, {
            body: body || '',
            tag: tag || 'famdesk',
            icon: 'icon-192.png',
            badge: 'icon-192.png',
            silent: false,
            requireInteraction: false
          })
          // Clicking the notification focuses the tab
          n.onclick = () => {
            window.focus()
            n.close()
          }
          // Auto-close after 8 seconds
          setTimeout(() => { try { n.close() } catch(_) {} }, 8000)
        } catch(e) {
          console.warn('[notif] Failed to send notification:', e)
        }
      }

      // Direct calls are made from showSessionView / appendChat / onDisconnected
      // via window.sendDesktopNotif + window._showNotifBadge (set above).
      // No patching needed â€” those functions check window.sendDesktopNotif at call-time.

      // Force notification (ignores visibility â€” for session-start which is important)
      function sendDesktopNotifForce(title, body) {
        if (!notifGranted()) return
        try {
          const n = new Notification(title, {
            body: body || '',
            tag: 'session-start',
            icon: 'icon-192.png',
            silent: false
          })
          n.onclick = () => { window.focus(); n.close() }
          setTimeout(() => { try { n.close() } catch(_) {} }, 8000)
        } catch(e) {}
      }

      // â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      refreshNotifUI()
      refreshNotifBadge()
    })()

    // â”€â”€ Phase 24: Browser QR Scanner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const scanQrBtn        = document.getElementById('scanQrBtn')
    const qrScannerOverlay = document.getElementById('qrScannerOverlay')
    const qrVideo          = document.getElementById('qrVideo')
    const qrCanvas         = document.getElementById('qrCanvas')
    const qrScanStatus     = document.getElementById('qrScanStatus')
    const qrCancelBtn      = document.getElementById('qrCancelBtn')

    let qrStream   = null
    let qrAnimFrame = null

    async function startQrScanner() {
      // Camera requires HTTPS â€” if on plain HTTP, redirect to HTTPS version on port 8443
      if (location.protocol === 'http:' && !location.hostname.match(/^(localhost|127\.|::1)/)) {
        const httpsUrl = 'https://' + location.hostname + ':8443' + location.pathname + location.search
        qrScannerOverlay.style.display = 'flex'
        qrScanStatus.innerHTML =
          'ğŸ”’ Camera needs HTTPS. <a href="' + httpsUrl + '" style="color:#6EE7F7">Open secure link</a> ' +
          '(accept the certificate warning once, then QR scanning works).'
        return
      }

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Camera not available in this browser. Enter the code manually.')
        return
      }

      if (typeof jsQR === 'undefined') {
        alert('QR scanner library not loaded â€” check your internet connection.')
        return
      }

      qrScannerOverlay.style.display = 'flex'
      qrScanStatus.textContent = 'Opening camera...'
      try {
        qrStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
        })
      } catch (e) {
        qrScanStatus.textContent = 'Camera access denied â€” enter code manually instead.'
        console.warn('[qr-scan] Camera error:', e.message)
        return
      }
      qrVideo.srcObject = qrStream
      qrScanStatus.textContent = 'Scanning â€” point at the QR code on their phoneâ€¦'
      qrVideo.addEventListener('loadedmetadata', () => { scanFrame() }, { once: true })
    }

    function scanFrame() {
      if (!qrStream) return
      const ctx = qrCanvas.getContext('2d', { willReadFrequently: true })
      const w = qrVideo.videoWidth || 300
      const h = qrVideo.videoHeight || 300
      qrCanvas.width = w
      qrCanvas.height = h
      ctx.drawImage(qrVideo, 0, 0, w, h)
      const imageData = ctx.getImageData(0, 0, w, h)
      const result = jsQR(imageData.data, w, h, { inversionAttempts: 'dontInvert' })
      if (result && result.data) {
        const url = result.data
        let code = null
        try {
          const match = url.match(/[?&]code=([A-Z0-9]{8})/i)
          if (match) code = match[1].toUpperCase()
          else if (/^[A-Z0-9]{8}$/i.test(url)) code = url.toUpperCase()
        } catch (e) {}
        if (code) {
          stopQrScanner()
          codeInput.value = code
          qrScanStatus.textContent = 'âœ… Code scanned!'
          setTimeout(() => { connect() }, 50)  // call directly â€” avoids user-gesture loss from .click()
          return
        }
        qrScanStatus.textContent = 'QR found but code not recognized â€” hold steady'
      }
      qrAnimFrame = requestAnimationFrame(scanFrame)
    }

    function stopQrScanner() {
      cancelAnimationFrame(qrAnimFrame)
      qrAnimFrame = null
      if (qrStream) { qrStream.getTracks().forEach(t => t.stop()); qrStream = null }
      qrScannerOverlay.style.display = 'none'
    }

    scanQrBtn.addEventListener('click', startQrScanner)
    qrCancelBtn.addEventListener('click', stopQrScanner)

    // Stop scanner if user clicks Connect manually while overlay is open
    connectBtn.addEventListener('click', () => { if (qrStream) stopQrScanner() }, true)

    // Note: do NOT hide scan button on HTTP â€” startQrScanner() already handles
    // this case gracefully by showing an HTTPS redirect link in the overlay.
  </script>

  <script>
  // â”€â”€ PWA Service Worker (Phase 86) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js')
      .then(() => console.log('[SW] FamDesk Helper service worker registered'))
      .catch(err => console.warn('[SW] Registration failed:', err))
  }
  </script>
</body>
</html>
